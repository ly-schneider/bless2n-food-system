
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">backend/internal/app/config.go (0.0%)</option>
				
				<option value="file1">backend/internal/app/database.go (0.0%)</option>
				
				<option value="file2">backend/internal/app/handlers.go (0.0%)</option>
				
				<option value="file3">backend/internal/app/logger.go (0.0%)</option>
				
				<option value="file4">backend/internal/app/repositories.go (0.0%)</option>
				
				<option value="file5">backend/internal/app/router.go (0.0%)</option>
				
				<option value="file6">backend/internal/app/server.go (0.0%)</option>
				
				<option value="file7">backend/internal/app/services.go (0.0%)</option>
				
				<option value="file8">backend/internal/config/config.go (0.0%)</option>
				
				<option value="file9">backend/internal/database/mongodb.go (0.0%)</option>
				
				<option value="file10">backend/internal/database/transaction.go (0.0%)</option>
				
				<option value="file11">backend/internal/handler/admin.go (0.0%)</option>
				
				<option value="file12">backend/internal/handler/auth.go (60.5%)</option>
				
				<option value="file13">backend/internal/handler/category.go (0.0%)</option>
				
				<option value="file14">backend/internal/handler/order.go (0.0%)</option>
				
				<option value="file15">backend/internal/handler/product.go (0.0%)</option>
				
				<option value="file16">backend/internal/handler/redemption.go (0.0%)</option>
				
				<option value="file17">backend/internal/handler/station.go (0.0%)</option>
				
				<option value="file18">backend/internal/handler/user.go (0.0%)</option>
				
				<option value="file19">backend/internal/http/router.go (0.0%)</option>
				
				<option value="file20">backend/internal/middleware/jwt.go (0.0%)</option>
				
				<option value="file21">backend/internal/middleware/security.go (0.0%)</option>
				
				<option value="file22">backend/internal/repository/admin_invite.go (0.0%)</option>
				
				<option value="file23">backend/internal/repository/category.go (0.0%)</option>
				
				<option value="file24">backend/internal/repository/device.go (0.0%)</option>
				
				<option value="file25">backend/internal/repository/device_request.go (0.0%)</option>
				
				<option value="file26">backend/internal/repository/inventory_ledger.go (0.0%)</option>
				
				<option value="file27">backend/internal/repository/order.go (0.0%)</option>
				
				<option value="file28">backend/internal/repository/order_item.go (0.0%)</option>
				
				<option value="file29">backend/internal/repository/otp_token.go (0.0%)</option>
				
				<option value="file30">backend/internal/repository/product.go (0.0%)</option>
				
				<option value="file31">backend/internal/repository/product_bundle_component.go (0.0%)</option>
				
				<option value="file32">backend/internal/repository/refresh_token.go (0.0%)</option>
				
				<option value="file33">backend/internal/repository/station.go (0.0%)</option>
				
				<option value="file34">backend/internal/repository/station_product.go (0.0%)</option>
				
				<option value="file35">backend/internal/repository/user.go (0.0%)</option>
				
				<option value="file36">backend/internal/response/response.go (0.0%)</option>
				
				<option value="file37">backend/internal/service/admin.go (0.0%)</option>
				
				<option value="file38">backend/internal/service/auth/auth.go (94.4%)</option>
				
				<option value="file39">backend/internal/service/auth/otp.go (76.5%)</option>
				
				<option value="file40">backend/internal/service/auth/token.go (93.8%)</option>
				
				<option value="file41">backend/internal/service/category.go (0.0%)</option>
				
				<option value="file42">backend/internal/service/email.go (85.7%)</option>
				
				<option value="file43">backend/internal/service/jwt.go (0.0%)</option>
				
				<option value="file44">backend/internal/service/order.go (0.0%)</option>
				
				<option value="file45">backend/internal/service/product.go (0.0%)</option>
				
				<option value="file46">backend/internal/service/station.go (0.0%)</option>
				
				<option value="file47">backend/internal/service/user.go (0.0%)</option>
				
				<option value="file48">backend/internal/utils/hash.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "backend/internal/config"
)

func NewConfig() config.Config <span class="cov0" title="0">{
        return config.Load()
}</span>

func ProvideAppConfig(cfg config.Config) config.AppConfig <span class="cov0" title="0">{
        return cfg.App
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "backend/internal/config"
        "backend/internal/database"
)

func NewDB(cfg config.Config) (*database.MongoDB, error) <span class="cov0" title="0">{
        return database.NewMongoDB(cfg)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "backend/internal/config"
        "backend/internal/handler"
        "backend/internal/middleware"

        "go.uber.org/fx"
)

func NewHandlers() fx.Option <span class="cov0" title="0">{
        return fx.Options(
                fx.Provide(
                        handler.NewAuthHandler,
                        handler.NewAdminHandler,
                        handler.NewUserHandler,
                        handler.NewStationHandler,
                        handler.NewCategoryHandler,
                        handler.NewProductHandler,
                        handler.NewOrderHandler,
                        handler.NewRedemptionHandler,
                        middleware.NewJWTMiddleware,
                        NewSecurityMiddleware,
                ),
        )
}</span>

func NewSecurityMiddleware(cfg config.Config) *middleware.SecurityMiddleware <span class="cov0" title="0">{
        return middleware.NewSecurityMiddleware(middleware.SecurityConfig{
                EnableHSTS:     cfg.Security.EnableHSTS,
                EnableCSP:      cfg.Security.EnableCSP,
                TrustedOrigins: cfg.Security.TrustedOrigins,
                AppEnv:         cfg.App.AppEnv,
        })
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "backend/internal/config"

        "go.uber.org/zap"
)

func NewLogger(cfg config.Config) (*zap.Logger, error) <span class="cov0" title="0">{
        var l *zap.Logger
        var err error

        if cfg.Logger.Development </span><span class="cov0" title="0">{
                l, err = zap.NewDevelopment()
        }</span> else<span class="cov0" title="0"> {
                l, err = zap.NewProduction()
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">zap.ReplaceGlobals(l)
        return l, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "backend/internal/repository"

        "go.uber.org/fx"
)

func NewRepositories() fx.Option <span class="cov0" title="0">{
        return fx.Options(
                fx.Provide(
                        repository.NewUserRepository,
                        repository.NewOTPTokenRepository,
                        repository.NewRefreshTokenRepository,
                        repository.NewAdminInviteRepository,
                        repository.NewStationRepository,
                        repository.NewDeviceRepository,
                        repository.NewDeviceRequestRepository,
                        repository.NewCategoryRepository,
                        repository.NewProductRepository,
                        repository.NewProductBundleComponentRepository,
                        repository.NewStationProductRepository,
                        repository.NewInventoryLedgerRepository,
                        repository.NewOrderRepository,
                        repository.NewOrderItemRepository,
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "net/http"

        "backend/internal/config"
        "backend/internal/handler"
        httpRouter "backend/internal/http"
        "backend/internal/middleware"
)

func NewRouter(
        authHandler *handler.AuthHandler,
        adminHandler *handler.AdminHandler,
        userHandler *handler.UserHandler,
        stationHandler *handler.StationHandler,
        categoryHandler *handler.CategoryHandler,
        productHandler *handler.ProductHandler,
        orderHandler *handler.OrderHandler,
        redemptionHandler *handler.RedemptionHandler,
        jwtMw *middleware.JWTMiddleware,
        securityMw *middleware.SecurityMiddleware,
        cfg config.Config,
) http.Handler <span class="cov0" title="0">{
        enableDocs := cfg.App.AppEnv != "prod"
        return httpRouter.NewRouter(authHandler, adminHandler, userHandler, stationHandler, categoryHandler, productHandler, orderHandler, redemptionHandler, jwtMw, securityMw, enableDocs)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "context"
        "net/http"

        "backend/internal/config"

        "go.uber.org/fx"
        "go.uber.org/zap"
)

func StartHTTPServer(lc fx.Lifecycle, cfg config.Config, router http.Handler) <span class="cov0" title="0">{
        server := &amp;http.Server{
                Addr:    ":" + cfg.App.AppPort,
                Handler: router,
        }

        lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        zap.L().Info("starting HTTP server", zap.String("port", cfg.App.AppPort))
                        go func() </span><span class="cov0" title="0">{
                                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                        zap.L().Fatal("failed to start HTTP server", zap.Error(err))
                                }</span>
                        }()
                        <span class="cov0" title="0">return nil</span>
                },
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        zap.L().Info("stopping HTTP server")
                        return server.Shutdown(ctx)
                }</span>,
        })
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "backend/internal/config"
        "backend/internal/repository"
        "backend/internal/service"
        "backend/internal/service/auth"

        "go.uber.org/fx"
)

func NewServices() fx.Option <span class="cov0" title="0">{
        return fx.Options(
                fx.Provide(
                        service.NewEmailService,
                        NewJWTService,
                        auth.NewOTPService,
                        auth.NewTokenService,
                        NewAuthService,
                        service.NewAdminService,
                        service.NewUserService,
                        service.NewStationService,
                        service.NewCategoryService,
                        service.NewProductService,
                        service.NewOrderService,
                ),
        )
}</span>

func NewAuthService(
        userRepo repository.UserRepository,
        otpService auth.OTPService,
        tokenService auth.TokenService,
) service.AuthService <span class="cov0" title="0">{
        return auth.NewService(userRepo, otpService, tokenService)
}</span>

func NewJWTService(cfg config.Config) service.JWTService <span class="cov0" title="0">{
        return service.NewJWTService(cfg.App.JWTPrivPEMPath, cfg.App.JWTPubPEMPath, cfg.App.JWTIssuer)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "fmt"
        "log"
        "os"
        "strconv"
        "strings"

        "github.com/joho/godotenv"
)

type Config struct {
        App      AppConfig
        Mongo    MongoConfig
        Logger   LoggerConfig
        Smtp     SmtpConfig
        Security SecurityConfig
}

type AppConfig struct {
        AppEnv         string
        AppPort        string
        JWTIssuer      string
        JWTPrivPEMPath string
        JWTPubPEMPath  string
}

type MongoConfig struct {
        URI      string
        Database string
}

type LoggerConfig struct {
        Level       string
        Development bool
}

type SmtpConfig struct {
        Host      string
        Port      string
        Username  string
        Password  string
        From      string
        TLSPolicy string
}

type SecurityConfig struct {
        EnableHSTS     bool
        EnableCSP      bool
        TrustedOrigins []string
}

func Load() Config <span class="cov0" title="0">{
        // Load .env files only if not in Docker environment
        if !isDockerEnvironment() </span><span class="cov0" title="0">{
                files := []string{".env"}

                if appEnv := os.Getenv("APP_ENV"); appEnv != "" &amp;&amp; appEnv != "local" </span><span class="cov0" title="0">{
                        envFile := fmt.Sprintf(".env.%s", appEnv)
                        if _, err := os.Stat(envFile); err == nil </span><span class="cov0" title="0">{
                                files = append(files, envFile)
                        }</span>
                }

                <span class="cov0" title="0">if err := godotenv.Overload(files...); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: could not load env files %v: %v", files, err)
                }</span>
        }

        <span class="cov0" title="0">cfg := Config{
                App: AppConfig{
                        AppEnv:         getEnv("APP_ENV"),
                        AppPort:        getEnv("APP_PORT"),
                        JWTIssuer:      getEnv("JWT_ISSUER"),
                        JWTPrivPEMPath: getEnv("JWT_PRIV_PEM_PATH"),
                        JWTPubPEMPath:  getEnv("JWT_PUB_PEM_PATH"),
                },
                Mongo: MongoConfig{
                        URI:      getEnv("MONGO_URI"),
                        Database: getEnv("MONGO_DATABASE"),
                },
                Logger: LoggerConfig{
                        Level:       getEnv("LOG_LEVEL"),
                        Development: getEnvAsBool("LOG_DEVELOPMENT"),
                },
                Smtp: SmtpConfig{
                        Host:      getEnv("SMTP_HOST"),
                        Port:      getEnv("SMTP_PORT"),
                        Username:  getEnv("SMTP_USERNAME"),
                        Password:  getEnv("SMTP_PASSWORD"),
                        From:      getEnv("SMTP_FROM"),
                        TLSPolicy: getEnv("SMTP_TLS_POLICY"),
                },
                Security: SecurityConfig{
                        EnableHSTS:     getEnvAsBool("SECURITY_ENABLE_HSTS"),
                        EnableCSP:      getEnvAsBool("SECURITY_ENABLE_CSP"),
                        TrustedOrigins: getTrustedOrigins("SECURITY_TRUSTED_ORIGINS"),
                },
        }

        return cfg</span>
}

// isDockerEnvironment checks if we're running inside a Docker container
func isDockerEnvironment() bool <span class="cov0" title="0">{
        if os.Getenv("DOCKER_CONTAINER") == "true" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat("/.dockerenv"); err == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// getEnv gets a environment variable or panics
func getEnv(key string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">log.Fatalf("config: environment variable %s is not set", key)
        return ""</span>
}

// getEnvAsBool gets an environment variable as a boolean or panics
func getEnvAsBool(key string) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">log.Fatalf("config: environment variable %s is not set", key)
        return false</span>
}

// getTrustedOrigins parses comma-separated list of trusted origins from environment
func getTrustedOrigins(key string) []string <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                log.Fatalf("config: environment variable %s is not set", key)
                return make([]string, 0)
        }</span>

        <span class="cov0" title="0">origins := strings.Split(value, ",")
        var trimmedOrigins []string
        for _, origin := range origins </span><span class="cov0" title="0">{
                if trimmed := strings.TrimSpace(origin); trimmed != "" </span><span class="cov0" title="0">{
                        trimmedOrigins = append(trimmedOrigins, trimmed)
                }</span>
        }
        <span class="cov0" title="0">return trimmedOrigins</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "context"
        "time"

        "backend/internal/config"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "go.uber.org/zap"
)

type MongoDB struct {
        Client   *mongo.Client
        Database *mongo.Database
}

func NewMongoDB(cfg config.Config) (*MongoDB, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        clientOptions := options.Client().ApplyURI(cfg.Mongo.URI)
        client, err := mongo.Connect(ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to connect to MongoDB", zap.Error(err))
                return nil, err
        }</span>

        // Ping the database to verify connection
        <span class="cov0" title="0">if err := client.Ping(ctx, nil); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to ping MongoDB", zap.Error(err))
                return nil, err
        }</span>

        // Use the configured database name
        <span class="cov0" title="0">dbName := cfg.Mongo.Database
        database := client.Database(dbName)
        zap.L().Info("successfully connected to MongoDB", zap.String("database", dbName))

        return &amp;MongoDB{
                Client:   client,
                Database: database,
        }, nil</span>
}

func (m *MongoDB) Close() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        return m.Client.Disconnect(ctx)
}</span>

// Collection names constants
const (
        UsersCollection                   = "users"
        AdminInvitesCollection            = "admin_invites"
        OTPTokensCollection               = "otp_tokens"
        RefreshTokensCollection           = "refresh_tokens"
        StationsCollection                = "stations"
        DevicesCollection                 = "devices"
        DeviceRequestsCollection          = "device_requests"
        CategoriesCollection              = "categories"
        ProductsCollection                = "products"
        ProductBundleComponentsCollection = "product_bundle_components"
        StationProductsCollection         = "station_products"
        InventoryLedgerCollection         = "inventory_ledger"
        OrdersCollection                  = "orders"
        OrderItemsCollection              = "order_items"
)
</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "context"

        "go.mongodb.org/mongo-driver/mongo"
)

// TransactionManager provides transaction support for MongoDB operations
type TransactionManager interface {
        WithTransaction(ctx context.Context, fn func(sessionContext mongo.SessionContext) error) error
}

type transactionManager struct {
        client *mongo.Client
}

func NewTransactionManager(db *MongoDB) TransactionManager <span class="cov0" title="0">{
        return &amp;transactionManager{
                client: db.Client,
        }
}</span>

// WithTransaction executes the provided function within a MongoDB transaction
func (tm *transactionManager) WithTransaction(ctx context.Context, fn func(sessionContext mongo.SessionContext) error) error <span class="cov0" title="0">{
        session, err := tm.client.StartSession()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer session.EndSession(ctx)

        // Execute the function within a transaction
        return mongo.WithSession(ctx, session, func(sc mongo.SessionContext) error </span><span class="cov0" title="0">{
                _, err := session.WithTransaction(sc, func(sc mongo.SessionContext) (interface{}, error) </span><span class="cov0" title="0">{
                        return nil, fn(sc)
                }</span>)
                <span class="cov0" title="0">return err</span>
        })
}</pre>
		
		<pre class="file" id="file11" style="display: none">package handler

import (
        "encoding/json"
        "net/http"
        "strconv"

        "backend/internal/middleware"
        "backend/internal/response"
        "backend/internal/service"

        "github.com/go-chi/chi/v5"
        "github.com/go-playground/validator/v10"
        "go.uber.org/zap"
)

type AdminHandler struct {
        adminService service.AdminService
        validator    *validator.Validate
}

func NewAdminHandler(adminService service.AdminService) *AdminHandler <span class="cov0" title="0">{
        return &amp;AdminHandler{
                adminService: adminService,
                validator:    validator.New(),
        }
}</span>

// ListCustomers godoc
// @Summary List all customers
// @Description Allow admins to list all customers
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param limit query int false "Limit size" minimum(1) maximum(100) default(50)
// @Param offset query int false "Offset" minimum(0) default(0)
// @Success 200 {object} service.ListCustomersResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/customers [get]
func (h *AdminHandler) ListCustomers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse query parameters
        limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 50 // default
        offset := 0 // default

        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">svcResp, err := h.adminService.ListCustomers(r.Context(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to list customers", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// BanCustomer godoc
// @Summary Ban a customer
// @Description Allow admins to ban a customer with a reason
// @Tags admin
// @Accept json
// @Produce json
// @Security Bearer
// @Param customer_id path string true "Customer ID"
// @Param request body service.BanCustomerRequest true "Ban reason payload"
// @Success 200 {object} service.BanCustomerResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/customers/{customer_id}/ban [post]
func (h *AdminHandler) BanCustomer(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get admin from JWT token
        _, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">customerID := chi.URLParam(r, "customer_id")
        if customerID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Customer ID is required")
                return
        }</span>

        <span class="cov0" title="0">var req service.BanCustomerRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.adminService.BanCustomer(r.Context(), customerID, req)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to ban customer", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// DeleteCustomer godoc
// @Summary Delete a customer
// @Description Allow admins to delete a customer
// @Tags admin
// @Produce json
// @Security Bearer
// @Param customer_id path string true "Customer ID"
// @Success 200 {object} service.DeleteCustomerResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/customers/{customer_id} [delete]
func (h *AdminHandler) DeleteCustomer(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get admin from JWT token
        _, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">customerID := chi.URLParam(r, "customer_id")
        if customerID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Customer ID is required")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.adminService.DeleteCustomer(r.Context(), customerID)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to delete customer", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// InviteAdmin godoc
// @Summary Invite admin
// @Description Allow admins to invite emails to become admins
// @Tags admin
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body service.InviteAdminRequest true "Admin invite payload"
// @Success 201 {object} service.InviteAdminResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/invites [post]
func (h *AdminHandler) InviteAdmin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get admin from JWT token
        admin, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">var req service.InviteAdminRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.adminService.InviteAdmin(r.Context(), admin.Subject, req)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to invite admin", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusCreated, svcResp)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handler

import (
        "encoding/json"
        "net/http"

        "backend/internal/response"
        "backend/internal/service"

        "github.com/go-playground/validator/v10"
        "go.uber.org/zap"
)

type AuthHandler struct {
        authService service.AuthService
        validator   *validator.Validate
}

func NewAuthHandler(authService service.AuthService) *AuthHandler <span class="cov10" title="15">{
        return &amp;AuthHandler{
                authService: authService,
                validator:   validator.New(),
        }
}</span>

// RegisterCustomer godoc
// @Summary Register customer
// @Description Register a new customer and send an OTP to email
// @Tags auth
// @Accept json
// @Produce json
// @Param request body service.RegisterCustomerRequest true "payload"
// @Success 201 {object} service.RegisterCustomerResponse
// @Failure 400 {object} response.ErrorResponse
// @Router /v1/auth/register/customer [post]
func (h *AuthHandler) RegisterCustomer(w http.ResponseWriter, r *http.Request) <span class="cov6" title="5">{
        var req service.RegisterCustomerRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov5" title="4">if err := h.validator.Struct(req); err != nil </span><span class="cov3" title="2">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov3" title="2">svcResp, err := h.authService.RegisterCustomer(r.Context(), req)
        if err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to register customer", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov1" title="1">response.WriteJSON(w, http.StatusCreated, svcResp)</span>
}

// RequestOTP godoc
// @Summary Request login OTP
// @Description Start passwordless login by requesting an OTP for the given email
// @Tags auth
// @Accept json
// @Produce json
// @Param request body service.RequestOTPRequest true "payload"
// @Success 200 {object} service.RequestOTPResponse
// @Failure 400 {object} response.ErrorResponse
// @Router /v1/auth/request-login-otp [post]
func (h *AuthHandler) RequestOTP(w http.ResponseWriter, r *http.Request) <span class="cov6" title="5">{
        var req service.RequestOTPRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov5" title="4">if err := h.validator.Struct(req); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov4" title="3">svcResp, err := h.authService.RequestOTP(r.Context(), req)
        if err != nil </span><span class="cov3" title="2">{
                zap.L().Error("failed to request login OTP", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov1" title="1">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// Login godoc
// @Summary Login with OTP
// @Description Exchange a valid OTP for an access/refresh token pair
// @Tags auth
// @Accept json
// @Produce json
// @Param request body service.LoginRequest true "payload"
// @Success 200 {object} service.LoginResponse
// @Failure 400 {object} response.ErrorResponse
// @Router /v1/auth/login [post]
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov6" title="5">{
        var req service.LoginRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov5" title="4">if err := h.validator.Struct(req); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov4" title="3">svcResp, err := h.authService.Login(r.Context(), req)
        if err != nil </span><span class="cov3" title="2">{
                zap.L().Error("failed to login", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov1" title="1">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// RefreshToken godoc
// @Summary Refresh tokens
// @Description Exchange a valid refresh token for a new access/refresh token pair
// @Tags auth
// @Accept json
// @Produce json
// @Param request body service.RefreshTokenRequest true "payload"
// @Success 200 {object} service.RefreshTokenResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Router /v1/auth/refresh [post]
func (h *AuthHandler) RefreshToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req service.RefreshTokenRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.authService.RefreshToken(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to refresh token", zap.Error(err))
                response.WriteError(w, http.StatusUnauthorized, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// Logout godoc
// @Summary Logout (invalidate refresh token)
// @Description Revoke the provided refresh token
// @Tags auth
// @Accept json
// @Produce json
// @Param request body service.LogoutRequest true "payload"
// @Success 200 {object} service.LogoutResponse
// @Failure 400 {object} response.ErrorResponse
// @Router /v1/auth/logout [post]
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req service.LogoutRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.authService.Logout(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to logout", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handler

import (
        "encoding/json"
        "net/http"
        "strconv"

        "backend/internal/middleware"
        "backend/internal/response"
        "backend/internal/service"

        "github.com/go-chi/chi/v5"
        "github.com/go-playground/validator/v10"
        "go.uber.org/zap"
)

type CategoryHandler struct {
        categoryService service.CategoryService
        validator       *validator.Validate
}

func NewCategoryHandler(categoryService service.CategoryService) *CategoryHandler <span class="cov0" title="0">{
        return &amp;CategoryHandler{
                categoryService: categoryService,
                validator:       validator.New(),
        }
}</span>

// CreateCategory godoc
// @Summary Create a new category
// @Description Allow admins to create a new category
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body service.CreateCategoryRequest true "Category creation payload"
// @Success 201 {object} service.CreateCategoryResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/categories [post]
func (h *CategoryHandler) CreateCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">var req service.CreateCategoryRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.categoryService.CreateCategory(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to create category", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusCreated, svcResp)</span>
}

// GetCategory godoc
// @Summary Get category by ID
// @Description Allow admins to get a category by ID
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param id path string true "Category ID"
// @Success 200 {object} service.GetCategoryResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/categories/{id} [get]
func (h *CategoryHandler) GetCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">categoryID := chi.URLParam(r, "id")
        if categoryID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Category ID is required")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.categoryService.GetCategory(r.Context(), categoryID)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to get category", zap.Error(err))
                if err.Error() == "category not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// UpdateCategory godoc
// @Summary Update category
// @Description Allow admins to update a category
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Category ID"
// @Param request body service.UpdateCategoryRequest true "Category update payload"
// @Success 200 {object} service.UpdateCategoryResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/categories/{id} [put]
func (h *CategoryHandler) UpdateCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">categoryID := chi.URLParam(r, "id")
        if categoryID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Category ID is required")
                return
        }</span>

        <span class="cov0" title="0">var req service.UpdateCategoryRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.categoryService.UpdateCategory(r.Context(), categoryID, req)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to update category", zap.Error(err))
                if err.Error() == "category not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// DeleteCategory godoc
// @Summary Delete category
// @Description Allow admins to delete a category
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param id path string true "Category ID"
// @Success 200 {object} service.DeleteCategoryResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/categories/{id} [delete]
func (h *CategoryHandler) DeleteCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">categoryID := chi.URLParam(r, "id")
        if categoryID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Category ID is required")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.categoryService.DeleteCategory(r.Context(), categoryID)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to delete category", zap.Error(err))
                if err.Error() == "category not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// ListCategories godoc
// @Summary List categories
// @Description Allow admins to list all categories
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param active_only query boolean false "Show only active categories" default(false)
// @Param limit query int false "Limit size" minimum(1) maximum(100) default(50)
// @Param offset query int false "Offset" minimum(0) default(0)
// @Success 200 {object} service.ListCategoriesResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/categories [get]
func (h *CategoryHandler) ListCategories(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")
        activeOnlyStr := r.URL.Query().Get("active_only")

        limit := 50
        offset := 0
        activeOnly := false

        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">if activeOnlyStr != "" </span><span class="cov0" title="0">{
                activeOnly = activeOnlyStr == "true"
        }</span>

        <span class="cov0" title="0">svcResp, err := h.categoryService.ListCategories(r.Context(), activeOnly, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to list categories", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// SetCategoryActive godoc
// @Summary Set category active status
// @Description Allow admins to activate or deactivate a category
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param id path string true "Category ID"
// @Param active query boolean true "Active status" default(true)
// @Success 200 {object} service.SetCategoryActiveResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/categories/{id}/status [put]
func (h *CategoryHandler) SetCategoryActive(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        _, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">categoryID := chi.URLParam(r, "id")
        if categoryID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Category ID is required")
                return
        }</span>

        <span class="cov0" title="0">activeStr := r.URL.Query().Get("active")
        if activeStr == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Active status is required")
                return
        }</span>

        <span class="cov0" title="0">isActive := activeStr == "true"

        svcResp, err := h.categoryService.SetCategoryActive(r.Context(), categoryID, isActive)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to set category active status", zap.Error(err))
                if err.Error() == "category not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package handler

import (
        "encoding/json"
        "net/http"
        "strconv"

        "backend/internal/domain"
        "backend/internal/middleware"
        "backend/internal/response"
        "backend/internal/service"

        "github.com/go-chi/chi/v5"
        "github.com/go-playground/validator/v10"
        "go.uber.org/zap"
)

type OrderHandler struct {
        orderService service.OrderService
        validator    *validator.Validate
        logger       *zap.Logger
}

func NewOrderHandler(orderService service.OrderService, logger *zap.Logger) *OrderHandler <span class="cov0" title="0">{
        return &amp;OrderHandler{
                orderService: orderService,
                validator:    validator.New(),
                logger:       logger,
        }
}</span>

// CreateOrder godoc
// @Summary Create a new order
// @Description Create a new order with items, either for authenticated users or with contact email for POS orders
// @Tags orders
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body service.CreateOrderRequest true "Order creation payload"
// @Success 201 {object} service.CreateOrderResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Router /v1/orders [post]
func (h *OrderHandler) CreateOrder(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req service.CreateOrderRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        // If customer_id is not provided in request, try to get it from context (authenticated user)
        <span class="cov0" title="0">if req.CustomerID == nil </span><span class="cov0" title="0">{
                if userClaim, ok := middleware.GetUserFromContext(r.Context()); ok </span><span class="cov0" title="0">{
                        req.CustomerID = &amp;userClaim.Subject
                }</span>
        }

        <span class="cov0" title="0">svcResp, err := h.orderService.CreateOrder(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create order", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusCreated, svcResp)</span>
}

// GetOrder godoc
// @Summary Get order by ID
// @Description Retrieve detailed information about a specific order including items
// @Tags orders
// @Produce json
// @Security BearerAuth
// @Param id path string true "Order ID"
// @Success 200 {object} service.GetOrderResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/orders/{id} [get]
func (h *OrderHandler) GetOrder(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        orderID := chi.URLParam(r, "id")
        if orderID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Order ID is required")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.orderService.GetOrder(r.Context(), orderID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get order", zap.Error(err))
                if err.Error() == "order not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// UpdateOrder godoc
// @Summary Update order
// @Description Update order details (limited to pending orders)
// @Tags orders
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Order ID"
// @Param request body service.UpdateOrderRequest true "Order update payload"
// @Success 200 {object} service.UpdateOrderResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/orders/{id} [put]
func (h *OrderHandler) UpdateOrder(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        orderID := chi.URLParam(r, "id")
        if orderID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Order ID is required")
                return
        }</span>

        <span class="cov0" title="0">var req service.UpdateOrderRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.orderService.UpdateOrder(r.Context(), orderID, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update order", zap.Error(err))
                if err.Error() == "order not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// DeleteOrder godoc
// @Summary Delete order
// @Description Delete an order (only pending or cancelled orders)
// @Tags orders
// @Produce json
// @Security BearerAuth
// @Param id path string true "Order ID"
// @Success 200 {object} service.DeleteOrderResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/orders/{id} [delete]
func (h *OrderHandler) DeleteOrder(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        orderID := chi.URLParam(r, "id")
        if orderID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Order ID is required")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.orderService.DeleteOrder(r.Context(), orderID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to delete order", zap.Error(err))
                if err.Error() == "order not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// ListOrders godoc
// @Summary List orders
// @Description List orders with optional filtering by status
// @Tags orders
// @Produce json
// @Security BearerAuth
// @Param status query string false "Filter by status" Enums(pending, paid, cancelled, refunded)
// @Param limit query int false "Limit size" minimum(1) maximum(100) default(50)
// @Param offset query int false "Offset" minimum(0) default(0)
// @Success 200 {object} service.ListOrdersResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Router /v1/orders [get]
func (h *OrderHandler) ListOrders(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        statusStr := r.URL.Query().Get("status")
        limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        req := service.ListOrdersRequest{}

        if statusStr != "" </span><span class="cov0" title="0">{
                status := domain.OrderStatus(statusStr)
                // Validate status
                validStatuses := []domain.OrderStatus{
                        domain.OrderStatusPending,
                        domain.OrderStatusPaid,
                        domain.OrderStatusCancelled,
                        domain.OrderStatusRefunded,
                }
                isValid := false
                for _, validStatus := range validStatuses </span><span class="cov0" title="0">{
                        if status == validStatus </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusBadRequest, "Invalid status value")
                        return
                }</span>
                <span class="cov0" title="0">req.Status = &amp;status</span>
        }

        <span class="cov0" title="0">if limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; limit &gt; 0 </span><span class="cov0" title="0">{
                        req.Limit = limit
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if offset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; offset &gt;= 0 </span><span class="cov0" title="0">{
                        req.Offset = offset
                }</span>
        }

        <span class="cov0" title="0">svcResp, err := h.orderService.ListOrders(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to list orders", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// UpdateOrderStatus godoc
// @Summary Update order status
// @Description Update the status of an order (admin only)
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param id path string true "Order ID"
// @Param status query string true "New status" Enums(pending, paid, cancelled, refunded)
// @Success 200 {object} service.UpdateOrderStatusResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/orders/{id}/status [put]
func (h *OrderHandler) UpdateOrderStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">orderID := chi.URLParam(r, "id")
        if orderID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Order ID is required")
                return
        }</span>

        <span class="cov0" title="0">statusStr := r.URL.Query().Get("status")
        if statusStr == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Status is required")
                return
        }</span>

        <span class="cov0" title="0">status := domain.OrderStatus(statusStr)
        // Validate status
        validStatuses := []domain.OrderStatus{
                domain.OrderStatusPending,
                domain.OrderStatusPaid,
                domain.OrderStatusCancelled,
                domain.OrderStatusRefunded,
        }
        isValid := false
        for _, validStatus := range validStatuses </span><span class="cov0" title="0">{
                if status == validStatus </span><span class="cov0" title="0">{
                        isValid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Invalid status value")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.orderService.UpdateOrderStatus(r.Context(), orderID, status)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update order status", zap.Error(err))
                if err.Error() == "order not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// GetMyOrders godoc
// @Summary Get current user's orders
// @Description Retrieve orders for the authenticated user
// @Tags orders
// @Produce json
// @Security BearerAuth
// @Param limit query int false "Limit size" minimum(1) maximum(100) default(50)
// @Param offset query int false "Offset" minimum(0) default(0)
// @Success 200 {object} service.ListOrdersResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Router /v1/orders/my [get]
func (h *OrderHandler) GetMyOrders(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 50
        offset := 0

        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">customerID := userClaim.Subject
        svcResp, err := h.orderService.GetOrdersByCustomer(r.Context(), customerID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get user orders", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

</pre>
		
		<pre class="file" id="file15" style="display: none">package handler

import (
        "encoding/json"
        "net/http"
        "strconv"

        "backend/internal/middleware"
        "backend/internal/response"
        "backend/internal/service"

        "github.com/go-chi/chi/v5"
        "github.com/go-playground/validator/v10"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.uber.org/zap"
)

type ProductHandler struct {
        productService service.ProductService
        validator      *validator.Validate
        logger         *zap.Logger
}

func NewProductHandler(productService service.ProductService, logger *zap.Logger) *ProductHandler <span class="cov0" title="0">{
        return &amp;ProductHandler{
                productService: productService,
                validator:      validator.New(),
                logger:         logger,
        }
}</span>

// CreateProduct godoc
// @Summary Create a new product
// @Description Create a new product with specified category, type, name, image, and price
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body service.CreateProductRequest true "Product creation payload"
// @Success 201 {object} service.CreateProductResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/products [post]
func (h *ProductHandler) CreateProduct(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">var req service.CreateProductRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.productService.CreateProduct(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create product", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusCreated, svcResp)</span>
}

// GetProduct godoc
// @Summary Get product by ID
// @Description Retrieve detailed information about a specific product
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param id path string true "Product ID"
// @Success 200 {object} service.GetProductResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/products/{id} [get]
func (h *ProductHandler) GetProduct(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">productID := chi.URLParam(r, "id")
        if productID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Product ID is required")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.productService.GetProduct(r.Context(), productID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get product", zap.Error(err))
                if err.Error() == "product not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// UpdateProduct godoc
// @Summary Update product
// @Description Update product details including category, name, image, and price
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Product ID"
// @Param request body service.UpdateProductRequest true "Product update payload"
// @Success 200 {object} service.UpdateProductResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/products/{id} [put]
func (h *ProductHandler) UpdateProduct(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">productID := chi.URLParam(r, "id")
        if productID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Product ID is required")
                return
        }</span>

        <span class="cov0" title="0">var req service.UpdateProductRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.productService.UpdateProduct(r.Context(), productID, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update product", zap.Error(err))
                if err.Error() == "product not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// DeleteProduct godoc
// @Summary Delete product
// @Description Remove a product from the system
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param id path string true "Product ID"
// @Success 200 {object} service.DeleteProductResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/products/{id} [delete]
func (h *ProductHandler) DeleteProduct(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">productID := chi.URLParam(r, "id")
        if productID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Product ID is required")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.productService.DeleteProduct(r.Context(), productID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to delete product", zap.Error(err))
                if err.Error() == "product not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// ListProducts godoc
// @Summary List products
// @Description List all products with optional category filtering
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param category_id query string false "Filter by category ID"
// @Param active_only query boolean false "Show only active products" default(false)
// @Param limit query int false "Limit size" minimum(1) maximum(100) default(50)
// @Param offset query int false "Offset" minimum(0) default(0)
// @Success 200 {object} service.ListProductsResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/products [get]
func (h *ProductHandler) ListProducts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">categoryIDStr := r.URL.Query().Get("category_id")
        limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")
        activeOnlyStr := r.URL.Query().Get("active_only")

        limit := 50
        offset := 0
        activeOnly := false

        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">if activeOnlyStr != "" </span><span class="cov0" title="0">{
                activeOnly = activeOnlyStr == "true"
        }</span>

        <span class="cov0" title="0">var categoryID *string
        if categoryIDStr != "" </span><span class="cov0" title="0">{
                categoryID = &amp;categoryIDStr
        }</span>

        <span class="cov0" title="0">svcResp, err := h.productService.ListProducts(r.Context(), categoryID, activeOnly, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to list products", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}


// SetProductActive godoc
// @Summary Set product active status
// @Description Activate or deactivate a product
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param id path string true "Product ID"
// @Param active query boolean true "Active status" default(true)
// @Success 200 {object} service.SetProductActiveResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/products/{id}/status [put]
func (h *ProductHandler) SetProductActive(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">productID := chi.URLParam(r, "id")
        if productID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Product ID is required")
                return
        }</span>

        <span class="cov0" title="0">activeStr := r.URL.Query().Get("active")
        if activeStr == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Active status is required")
                return
        }</span>

        <span class="cov0" title="0">isActive := activeStr == "true"

        svcResp, err := h.productService.SetProductActive(r.Context(), productID, isActive)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to set product active status", zap.Error(err))
                if err.Error() == "product not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// UpdateProductStock godoc
// @Summary Update product stock
// @Description Update product inventory stock levels
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Product ID"
// @Param request body service.UpdateProductStockRequest true "Stock update payload"
// @Success 200 {object} service.UpdateProductStockResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/products/{id}/stock [put]
func (h *ProductHandler) UpdateProductStock(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">productID := chi.URLParam(r, "id")
        if productID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Product ID is required")
                return
        }</span>

        <span class="cov0" title="0">var req service.UpdateProductStockRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.productService.UpdateProductStock(r.Context(), productID, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update product stock", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// CreateProductBundle godoc
// @Summary Create a new product bundle (menu)
// @Description Create a new product bundle with multiple component products
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body service.CreateProductBundleRequest true "Bundle creation payload"
// @Success 201 {object} service.CreateProductBundleResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/products/bundles [post]
func (h *ProductHandler) CreateProductBundle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">var req service.CreateProductBundleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.productService.CreateProductBundle(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create product bundle", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusCreated, svcResp)</span>
}

// UpdateProductBundle godoc
// @Summary Update product bundle
// @Description Update an existing product bundle and its components
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Bundle ID"
// @Param request body service.UpdateProductBundleRequest true "Bundle update payload"
// @Success 200 {object} service.UpdateProductBundleResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/products/bundles/{id} [put]
func (h *ProductHandler) UpdateProductBundle(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">bundleID := chi.URLParam(r, "id")
        if bundleID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Bundle ID is required")
                return
        }</span>

        <span class="cov0" title="0">var req service.UpdateProductBundleRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.productService.UpdateProductBundle(r.Context(), bundleID, req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to update product bundle", zap.Error(err))
                if err.Error() == "bundle not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}


// AssignProductToStations godoc
// @Summary Assign product to stations
// @Description Assign a product to multiple stations for availability
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Product ID"
// @Param stationIds body []string true "Station IDs to assign the product to"
// @Success 200 {object} service.AssignProductToStationsResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/admin/products/{id}/stations [post]
func (h *ProductHandler) AssignProductToStations(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">productID := chi.URLParam(r, "id")
        if productID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Product ID is required")
                return
        }</span>

        <span class="cov0" title="0">var stationIDStrs []string
        if err := json.NewDecoder(r.Body).Decode(&amp;stationIDStrs); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request format")
                return
        }</span>

        <span class="cov0" title="0">stationIDs := make([]primitive.ObjectID, len(stationIDStrs))
        for i, idStr := range stationIDStrs </span><span class="cov0" title="0">{
                stationID, err := primitive.ObjectIDFromHex(idStr)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Invalid station ID", zap.String("stationID", idStr), zap.Error(err))
                        response.WriteError(w, http.StatusBadRequest, "Invalid station ID: "+idStr)
                        return
                }</span>
                <span class="cov0" title="0">stationIDs[i] = stationID</span>
        }

        <span class="cov0" title="0">svcResp, err := h.productService.AssignProductToStations(r.Context(), productID, stationIDs)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to assign product to stations", zap.Error(err))
                if err.Error() == "product not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}</pre>
		
		<pre class="file" id="file16" style="display: none">package handler

import (
        "encoding/json"
        "net/http"

        "backend/internal/response"
        "backend/internal/service"

        "github.com/go-chi/chi/v5"
        "github.com/go-playground/validator/v10"
        "go.uber.org/zap"
)

type RedemptionHandler struct {
        orderService service.OrderService
        validator    *validator.Validate
        logger       *zap.Logger
}

func NewRedemptionHandler(orderService service.OrderService, logger *zap.Logger) *RedemptionHandler <span class="cov0" title="0">{
        return &amp;RedemptionHandler{
                orderService: orderService,
                validator:    validator.New(),
                logger:       logger,
        }
}</span>

// GetOrderForRedemption godoc
// @Summary Get order details for redemption at a station
// @Description Get order details and items available for redemption at a specific station (scanned QR code)
// @Tags redemption
// @Produce json
// @Param order_id path string true "Order ID"
// @Param station_id query string true "Station ID"
// @Success 200 {object} service.OrderRedemptionResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/redemption/orders/{order_id} [get]
func (h *RedemptionHandler) GetOrderForRedemption(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        orderID := chi.URLParam(r, "order_id")
        if orderID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Order ID is required")
                return
        }</span>

        <span class="cov0" title="0">stationID := r.URL.Query().Get("station_id")
        if stationID == "" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusBadRequest, "Station ID is required")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.orderService.GetOrderForRedemption(r.Context(), orderID, stationID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get order for redemption", zap.Error(err))
                if err.Error() == "order not found" || err.Error() == "station not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// RedeemOrderItems godoc
// @Summary Redeem order items at a station
// @Description Redeem all available order items for a specific station (device confirms redemption)
// @Tags redemption
// @Accept json
// @Produce json
// @Param request body service.RedeemOrderItemsRequest true "Redemption request"
// @Success 200 {object} service.RedeemOrderItemsResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/redemption/redeem [post]
func (h *RedemptionHandler) RedeemOrderItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req service.RedeemOrderItemsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.orderService.RedeemOrderItems(r.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to redeem order items", zap.Error(err))
                if err.Error() == "order not found" || err.Error() == "device not found" </span><span class="cov0" title="0">{
                        response.WriteError(w, http.StatusNotFound, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        response.WriteError(w, http.StatusBadRequest, err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">package handler

import (
        "encoding/json"
        "net/http"
        "strconv"

        "backend/internal/domain"
        "backend/internal/middleware"
        "backend/internal/response"
        "backend/internal/service"

        "github.com/go-chi/chi/v5"
        "github.com/go-playground/validator/v10"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.uber.org/zap"
)

type StationHandler struct {
        stationService service.StationService
        validator      *validator.Validate
        logger         *zap.Logger
}

func NewStationHandler(stationService service.StationService, logger *zap.Logger) *StationHandler <span class="cov0" title="0">{
        return &amp;StationHandler{
                stationService: stationService,
                validator:      validator.New(),
                logger:         logger,
        }
}</span>

// RequestStation godoc
// @Summary Request to become a station (Public)
// @Description Allow anyone to request to become a station without authentication
// @Tags stations
// @Accept json
// @Produce json
// @Param request body domain.StationRequest true "Station request"
// @Success 201 {object} service.StationResponse
// @Failure 400 {object} response.ErrorResponse
// @Router /v1/stations/request [post]
func (h *StationHandler) RequestStation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req domain.StationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request format")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">stationResponse, err := h.stationService.CreateStation(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create station request", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusCreated, stationResponse)</span>
}

// CreateStation godoc
// @Summary Create a new station (Admin only)
// @Description Allow admins to create a new station
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param request body domain.StationRequest true "Station request"
// @Success 201 {object} service.StationResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/stations [post]
func (h *StationHandler) CreateStation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        // Only admins can create stations
        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">var req domain.StationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request format")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">stationResponse, err := h.stationService.CreateStation(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to create station", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusCreated, stationResponse)</span>
}

// ListStations godoc
// @Summary List all stations
// @Description List all stations with optional filtering
// @Tags stations
// @Produce json
// @Security BearerAuth
// @Param status query string false "Filter by status" Enums(pending, approved, rejected)
// @Param limit query int false "Limit size" minimum(1) maximum(100) default(50)
// @Param offset query int false "Offset" minimum(0) default(0)
// @Success 200 {object} service.ListStationsResponse
// @Failure 401 {object} response.ErrorResponse
// @Router /v1/stations [get]
func (h *StationHandler) ListStations(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse query parameters
        statusStr := r.URL.Query().Get("status")
        limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 50 // default
        offset := 0 // default

        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">var stationsResponse *service.ListStationsResponse
        var err error

        if statusStr != "" </span><span class="cov0" title="0">{
                status := domain.StationStatus(statusStr)
                // Validate status
                switch status </span>{
                case domain.StationStatusPending, domain.StationStatusApproved, domain.StationStatusRejected:<span class="cov0" title="0">
                        stationsResponse, err = h.stationService.ListStationsByStatus(r.Context(), status, limit, offset)</span>
                default:<span class="cov0" title="0">
                        response.WriteError(w, http.StatusBadRequest, "Invalid status parameter")
                        return</span>
                }
        } else<span class="cov0" title="0"> {
                stationsResponse, err = h.stationService.ListStations(r.Context(), limit, offset)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to list stations", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, "Failed to list stations")
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, stationsResponse)</span>
}

// GetStation godoc
// @Summary Get station by ID
// @Description Get detailed information about a specific station
// @Tags stations
// @Produce json
// @Security BearerAuth
// @Param id path string true "Station ID"
// @Success 200 {object} service.StationResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 404 {object} response.ErrorResponse
// @Router /v1/stations/{id} [get]
func (h *StationHandler) GetStation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        stationIDStr := chi.URLParam(r, "id")
        stationID, err := primitive.ObjectIDFromHex(stationIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid station ID", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid station ID")
                return
        }</span>

        <span class="cov0" title="0">stationResponse, err := h.stationService.GetStation(r.Context(), stationID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get station", zap.Error(err))
                response.WriteError(w, http.StatusNotFound, "Station not found")
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, stationResponse)</span>
}

// UpdateStationStatus godoc
// @Summary Update station status (approve or reject) (Admin only)
// @Description Allow admins to approve or reject station requests
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Station ID"
// @Param request body domain.StationStatusRequest true "Station status request"
// @Success 200 {object} service.StatusResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/stations/{id}/status [put]
func (h *StationHandler) UpdateStationStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        // Only admins can approve/reject stations
        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">adminID, err := primitive.ObjectIDFromHex(userClaim.Subject)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid admin ID", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid admin ID")
                return
        }</span>

        <span class="cov0" title="0">stationIDStr := chi.URLParam(r, "id")
        stationID, err := primitive.ObjectIDFromHex(stationIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid station ID", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid station ID")
                return
        }</span>

        <span class="cov0" title="0">var req domain.StationStatusRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request format")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">var statusResponse *service.StatusResponse
        if req.Approve != nil &amp;&amp; *req.Approve </span><span class="cov0" title="0">{
                statusResponse, err = h.stationService.ApproveStation(r.Context(), stationID, adminID)
        }</span> else<span class="cov0" title="0"> {
                reason := ""
                if req.Reason != nil </span><span class="cov0" title="0">{
                        reason = *req.Reason
                }</span>
                <span class="cov0" title="0">statusResponse, err = h.stationService.RejectStation(r.Context(), stationID, adminID, reason)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to process station status update", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, "Failed to process status update")
                return
        }</span>

        <span class="cov0" title="0">status := http.StatusOK
        if !statusResponse.Success </span><span class="cov0" title="0">{
                status = http.StatusBadRequest
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, status, statusResponse)</span>
}

// AssignProductsToStation godoc
// @Summary Assign products to a station (Admin only)
// @Description Allow admins to assign products to approved stations
// @Tags admin
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Station ID"
// @Param productIds body []string true "Product IDs to assign"
// @Success 200 {object} service.AssignProductsResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/stations/{id}/products [post]
func (h *StationHandler) AssignProductsToStation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        // Only admins can assign products
        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">stationIDStr := chi.URLParam(r, "id")
        stationID, err := primitive.ObjectIDFromHex(stationIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid station ID", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid station ID")
                return
        }</span>

        <span class="cov0" title="0">var productIDStrs []string
        if err := json.NewDecoder(r.Body).Decode(&amp;productIDStrs); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request format")
                return
        }</span>

        // Convert string IDs to ObjectIDs
        <span class="cov0" title="0">productIDs := make([]primitive.ObjectID, len(productIDStrs))
        for i, idStr := range productIDStrs </span><span class="cov0" title="0">{
                productID, err := primitive.ObjectIDFromHex(idStr)
                if err != nil </span><span class="cov0" title="0">{
                        h.logger.Error("Invalid product ID", zap.String("productID", idStr), zap.Error(err))
                        response.WriteError(w, http.StatusBadRequest, "Invalid product ID: "+idStr)
                        return
                }</span>
                <span class="cov0" title="0">productIDs[i] = productID</span>
        }

        <span class="cov0" title="0">assignResponse, err := h.stationService.AssignProductsToStation(r.Context(), stationID, productIDs)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to assign products to station", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, "Failed to assign products")
                return
        }</span>

        <span class="cov0" title="0">status := http.StatusOK
        if !assignResponse.Success </span><span class="cov0" title="0">{
                status = http.StatusBadRequest
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, status, assignResponse)</span>
}

// GetStationProducts godoc
// @Summary Get products assigned to a station
// @Description Get list of products assigned to a specific station
// @Tags stations
// @Produce json
// @Security BearerAuth
// @Param id path string true "Station ID"
// @Success 200 {object} service.StationProductsResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Router /v1/stations/{id}/products [get]
func (h *StationHandler) GetStationProducts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        stationIDStr := chi.URLParam(r, "id")
        stationID, err := primitive.ObjectIDFromHex(stationIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid station ID", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid station ID")
                return
        }</span>

        <span class="cov0" title="0">productsResponse, err := h.stationService.GetStationProducts(r.Context(), stationID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get station products", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, "Failed to get station products")
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, productsResponse)</span>
}

// RemoveProductFromStation godoc
// @Summary Remove product from station (Admin only)
// @Description Allow admins to remove a product from a station
// @Tags admin
// @Produce json
// @Security BearerAuth
// @Param id path string true "Station ID"
// @Param productId path string true "Product ID"
// @Success 200 {object} service.AssignProductsResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Failure 403 {object} response.ErrorResponse
// @Router /v1/admin/stations/{id}/products/{productId} [delete]
func (h *StationHandler) RemoveProductFromStation(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userClaim, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                h.logger.Error("User claims not found in context")
                response.WriteError(w, http.StatusUnauthorized, "Unauthorized")
                return
        }</span>

        // Only admins can remove products
        <span class="cov0" title="0">if string(userClaim.Role) != "admin" </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusForbidden, "Access denied")
                return
        }</span>

        <span class="cov0" title="0">stationIDStr := chi.URLParam(r, "id")
        stationID, err := primitive.ObjectIDFromHex(stationIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid station ID", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid station ID")
                return
        }</span>

        <span class="cov0" title="0">productIDStr := chi.URLParam(r, "productId")
        productID, err := primitive.ObjectIDFromHex(productIDStr)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Invalid product ID", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid product ID")
                return
        }</span>

        <span class="cov0" title="0">removeResponse, err := h.stationService.RemoveProductFromStation(r.Context(), stationID, productID)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to remove product from station", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, "Failed to remove product")
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, removeResponse)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handler

import (
        "encoding/json"
        "net/http"

        _ "backend/internal/domain"
        "backend/internal/middleware"
        "backend/internal/response"
        "backend/internal/service"

        "github.com/go-playground/validator/v10"
        "go.uber.org/zap"
)

type UserHandler struct {
        userService service.UserService
        validator   *validator.Validate
}

func NewUserHandler(userService service.UserService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService: userService,
                validator:   validator.New(),
        }
}</span>

// GetProfile godoc
// @Summary Get customer profile
// @Description Get the customer's profile information
// @Tags users
// @Produce json
// @Security Bearer
// @Success 200 {object} domain.User
// @Failure 401 {object} response.ErrorResponse
// @Router /v1/users/profile [get]
func (h *UserHandler) GetProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get user from JWT token
        user, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">profile, err := h.userService.GetProfile(r.Context(), user.Subject)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to get profile", zap.Error(err))
                response.WriteError(w, http.StatusInternalServerError, "Failed to get profile")
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, profile)</span>
}

// UpdateProfile godoc
// @Summary Update customer profile
// @Description Allow customers to update their email address
// @Tags users
// @Accept json
// @Produce json
// @Security Bearer
// @Param request body service.UpdateProfileRequest true "Profile update payload"
// @Success 200 {object} service.UpdateProfileResponse
// @Failure 400 {object} response.ErrorResponse
// @Failure 401 {object} response.ErrorResponse
// @Router /v1/users/profile [put]
func (h *UserHandler) UpdateProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get user from JWT token
        user, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">var req service.UpdateProfileRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to decode request body", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.validator.Struct(req); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("validation failed", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, "Validation failed: "+err.Error())
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.userService.UpdateProfile(r.Context(), user.Subject, req)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to update profile", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}

// DeleteProfile godoc
// @Summary Delete customer profile
// @Description Allow customers to delete their own profile
// @Tags users
// @Produce json
// @Security Bearer
// @Success 200 {object} service.DeleteProfileResponse
// @Failure 401 {object} response.ErrorResponse
// @Router /v1/users/profile [delete]
func (h *UserHandler) DeleteProfile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Get user from JWT token
        user, ok := middleware.GetUserFromContext(r.Context())
        if !ok </span><span class="cov0" title="0">{
                response.WriteError(w, http.StatusUnauthorized, "Authentication required")
                return
        }</span>

        <span class="cov0" title="0">svcResp, err := h.userService.DeleteProfile(r.Context(), user.Subject)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to delete profile", zap.Error(err))
                response.WriteError(w, http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.WriteJSON(w, http.StatusOK, svcResp)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package http

import (
        "net/http"

        "backend/internal/handler"
        jwtMiddleware "backend/internal/middleware"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"

        httpSwagger "github.com/swaggo/http-swagger"
)

func NewRouter(
        authHandler *handler.AuthHandler,
        adminHandler *handler.AdminHandler,
        userHandler *handler.UserHandler,
        stationHandler *handler.StationHandler,
        categoryHandler *handler.CategoryHandler,
        productHandler *handler.ProductHandler,
        orderHandler *handler.OrderHandler,
        redemptionHandler *handler.RedemptionHandler,
        jwtMw *jwtMiddleware.JWTMiddleware,
        securityMw *jwtMiddleware.SecurityMiddleware,
        enableDocs bool,
) http.Handler <span class="cov0" title="0">{
        r := chi.NewRouter()

        // Security middleware (applied first for all requests)
        r.Use(securityMw.SecurityHeaders)
        r.Use(securityMw.CacheControlForSensitive)
        r.Use(securityMw.CORS)

        // Standard middleware
        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(middleware.RequestID)
        r.Use(middleware.RealIP)
        r.Use(middleware.Heartbeat("/ping"))

        if enableDocs </span><span class="cov0" title="0">{
                r.Get("/swagger/*", httpSwagger.WrapHandler)
        }</span>

        <span class="cov0" title="0">r.Route("/v1", func(v1 chi.Router) </span><span class="cov0" title="0">{
                // Auth routes (public)
                v1.Route("/auth", func(auth chi.Router) </span><span class="cov0" title="0">{
                        auth.Post("/register/customer", authHandler.RegisterCustomer)
                        auth.Post("/request-otp", authHandler.RequestOTP)
                        auth.Post("/login", authHandler.Login)
                        auth.Post("/refresh", authHandler.RefreshToken)
                        auth.Post("/logout", authHandler.Logout)
                }</span>)

                // Public station request route
                <span class="cov0" title="0">v1.Post("/stations/request", stationHandler.RequestStation)

                // Public redemption routes (for station devices)
                v1.Route("/redemption", func(redemption chi.Router) </span><span class="cov0" title="0">{
                        redemption.Get("/orders/{order_id}", redemptionHandler.GetOrderForRedemption)
                        redemption.Post("/redeem", redemptionHandler.RedeemOrderItems)
                }</span>)

                // Protected routes - require authentication
                <span class="cov0" title="0">v1.Group(func(protected chi.Router) </span><span class="cov0" title="0">{
                        protected.Use(jwtMw.RequireAuth)

                        // User routes
                        protected.Route("/users", func(user chi.Router) </span><span class="cov0" title="0">{
                                user.Get("/profile", userHandler.GetProfile)
                                user.Put("/profile", userHandler.UpdateProfile)
                        }</span>)

                        // Station routes (public access for viewing)
                        <span class="cov0" title="0">protected.Route("/stations", func(station chi.Router) </span><span class="cov0" title="0">{
                                station.Get("/", stationHandler.ListStations)
                                station.Get("/{id}", stationHandler.GetStation)
                                station.Get("/{id}/products", stationHandler.GetStationProducts)
                        }</span>)

                        // Order routes
                        <span class="cov0" title="0">protected.Route("/orders", func(order chi.Router) </span><span class="cov0" title="0">{
                                order.Post("/", orderHandler.CreateOrder)
                                order.Get("/", orderHandler.ListOrders)
                                order.Get("/my", orderHandler.GetMyOrders)
                                order.Get("/{id}", orderHandler.GetOrder)
                                order.Put("/{id}", orderHandler.UpdateOrder)
                                order.Delete("/{id}", orderHandler.DeleteOrder)
                        }</span>)

                        // Admin-only routes
                        <span class="cov0" title="0">protected.Group(func(admin chi.Router) </span><span class="cov0" title="0">{
                                admin.Use(jwtMw.RequireRole("admin"))

                                admin.Route("/admin", func(adminRoutes chi.Router) </span><span class="cov0" title="0">{
                                        // Customer management
                                        adminRoutes.Get("/customers", adminHandler.ListCustomers)
                                        adminRoutes.Put("/customers/{id}/ban", adminHandler.BanCustomer)
                                        adminRoutes.Delete("/customers/{id}", adminHandler.DeleteCustomer)
                                        adminRoutes.Post("/invites", adminHandler.InviteAdmin)

                                        // Category management
                                        adminRoutes.Post("/categories", categoryHandler.CreateCategory)
                                        adminRoutes.Get("/categories", categoryHandler.ListCategories)
                                        adminRoutes.Get("/categories/{id}", categoryHandler.GetCategory)
                                        adminRoutes.Put("/categories/{id}", categoryHandler.UpdateCategory)
                                        adminRoutes.Delete("/categories/{id}", categoryHandler.DeleteCategory)
                                        adminRoutes.Put("/categories/{id}/status", categoryHandler.SetCategoryActive)

                                        // Product management
                                        adminRoutes.Post("/products", productHandler.CreateProduct)
                                        adminRoutes.Get("/products", productHandler.ListProducts)
                                        adminRoutes.Get("/products/{id}", productHandler.GetProduct)
                                        adminRoutes.Put("/products/{id}", productHandler.UpdateProduct)
                                        adminRoutes.Delete("/products/{id}", productHandler.DeleteProduct)
                                        adminRoutes.Put("/products/{id}/status", productHandler.SetProductActive)
                                        adminRoutes.Put("/products/{id}/stock", productHandler.UpdateProductStock)
                                        adminRoutes.Post("/products/{id}/stations", productHandler.AssignProductToStations)

                                        // Product bundle management (menus)
                                        adminRoutes.Post("/products/bundles", productHandler.CreateProductBundle)
                                        adminRoutes.Put("/products/bundles/{id}", productHandler.UpdateProductBundle)

                                        // Station management
                                        adminRoutes.Post("/stations", stationHandler.CreateStation)
                                        adminRoutes.Put("/stations/{id}/status", stationHandler.UpdateStationStatus)
                                        adminRoutes.Post("/stations/{id}/products", stationHandler.AssignProductsToStation)
                                        adminRoutes.Delete("/stations/{id}/products/{productId}", stationHandler.RemoveProductFromStation)

                                        // Order management
                                        adminRoutes.Put("/orders/{id}/status", orderHandler.UpdateOrderStatus)
                                }</span>)
                        })
                })
        })

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "context"
        "net/http"
        "slices"
        "strings"

        "backend/internal/service"

        "go.uber.org/zap"
)

type contextKey string

const (
        UserContextKey contextKey = "user"
)

type JWTMiddleware struct {
        jwtService service.JWTService
}

func NewJWTMiddleware(jwtService service.JWTService) *JWTMiddleware <span class="cov0" title="0">{
        return &amp;JWTMiddleware{
                jwtService: jwtService,
        }
}</span>

func (m *JWTMiddleware) RequireAuth(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                token := m.extractToken(r)
                if token == "" </span><span class="cov0" title="0">{
                        m.writeErrorResponse(w, http.StatusUnauthorized, "Missing authorization token")
                        return
                }</span>

                <span class="cov0" title="0">claims, err := m.jwtService.ValidateAccessToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        zap.L().Debug("token validation failed", zap.Error(err))
                        m.writeErrorResponse(w, http.StatusUnauthorized, "Invalid or expired token")
                        return
                }</span>

                // Add user info to context
                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), UserContextKey, claims)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

func (m *JWTMiddleware) OptionalAuth(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                token := m.extractToken(r)
                if token != "" </span><span class="cov0" title="0">{
                        if claims, err := m.jwtService.ValidateAccessToken(token); err == nil </span><span class="cov0" title="0">{
                                ctx := context.WithValue(r.Context(), UserContextKey, claims)
                                r = r.WithContext(ctx)
                        }</span>
                }
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func (m *JWTMiddleware) RequireRole(roles ...string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        claims, ok := r.Context().Value(UserContextKey).(*service.TokenClaims)
                        if !ok </span><span class="cov0" title="0">{
                                m.writeErrorResponse(w, http.StatusUnauthorized, "Authentication required")
                                return
                        }</span>

                        <span class="cov0" title="0">userRole := string(claims.Role)
                        hasRole := slices.Contains(roles, userRole)

                        if !hasRole </span><span class="cov0" title="0">{
                                zap.L().Warn("insufficient permissions",
                                        zap.String("user_id", claims.Subject),
                                        zap.String("user_role", userRole),
                                        zap.Strings("required_roles", roles))
                                m.writeErrorResponse(w, http.StatusForbidden, "Insufficient permissions")
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

func (m *JWTMiddleware) extractToken(r *http.Request) string <span class="cov0" title="0">{
        // Check Authorization header only
        authHeader := r.Header.Get("Authorization")
        if authHeader != "" </span><span class="cov0" title="0">{
                parts := strings.SplitN(authHeader, " ", 2)
                if len(parts) == 2 &amp;&amp; strings.ToLower(parts[0]) == "bearer" </span><span class="cov0" title="0">{
                        return parts[1]
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func (m *JWTMiddleware) writeErrorResponse(w http.ResponseWriter, status int, message string) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        response := `{"error": true, "message": "` + message + `", "status": ` +
                strings.TrimSpace(strings.Fields(http.StatusText(status))[0]) + `}`
        w.Write([]byte(response))
}</span>

func GetUserFromContext(ctx context.Context) (*service.TokenClaims, bool) <span class="cov0" title="0">{
        user, ok := ctx.Value(UserContextKey).(*service.TokenClaims)
        return user, ok
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package middleware

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "net/http"
        "net/url"
        "strings"
)

const NonceContextKey contextKey = "csp_nonce"

func WithNonce(ctx context.Context, nonce string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, NonceContextKey, nonce)
}</span>
func GetNonce(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        nonce, ok := ctx.Value(NonceContextKey).(string)
        return nonce, ok
}</span>

// --- middleware config ---
type SecurityMiddleware struct {
        enableHSTS     bool
        enableCSP      bool
        trustedOrigins []string
        appEnv         string
}

type SecurityConfig struct {
        EnableHSTS     bool     `json:"enable_hsts"`
        EnableCSP      bool     `json:"enable_csp"`
        TrustedOrigins []string `json:"trusted_origins"`
        AppEnv         string   `json:"app_env"`
}

func NewSecurityMiddleware(cfg SecurityConfig) *SecurityMiddleware <span class="cov0" title="0">{
        return &amp;SecurityMiddleware{
                enableHSTS:     cfg.EnableHSTS,
                enableCSP:      cfg.EnableCSP,
                trustedOrigins: cfg.TrustedOrigins,
                appEnv:         strings.ToLower(cfg.AppEnv),
        }
}</span>

func generateNonce() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 16) // 128-bit
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(b), nil</span>
}

func isHTTPS(r *http.Request) bool <span class="cov0" title="0">{
        if r.TLS != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return strings.EqualFold(r.Header.Get("X-Forwarded-Proto"), "https")</span>
}

func (s *SecurityMiddleware) isOriginAllowed(origin string) bool <span class="cov0" title="0">{
        if origin == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, o := range s.trustedOrigins </span><span class="cov0" title="0">{
                if o == origin </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (s *SecurityMiddleware) SecurityHeaders(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")

                w.Header().Set("X-Frame-Options", "DENY")

                // HSTS only when enabled AND over HTTPS (avoid on dev/http)
                if s.enableHSTS &amp;&amp; s.appEnv != "dev" &amp;&amp; isHTTPS(r) </span><span class="cov0" title="0">{
                        // If ALL subdomains are HTTPS, includeSubDomains + preload are fine.
                        w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
                }</span>

                // CSP: Report-Only in dev, Enforcing in staging/prod
                <span class="cov0" title="0">if s.enableCSP </span><span class="cov0" title="0">{
                        if nonce, err := generateNonce(); err == nil </span><span class="cov0" title="0">{
                                headerName := "Content-Security-Policy"
                                if s.appEnv == "dev" </span><span class="cov0" title="0">{
                                        headerName = "Content-Security-Policy-Report-Only"
                                }</span>

                                // Base policy (nonce-based JS)
                                <span class="cov0" title="0">var csp strings.Builder
                                fmt.Fprintf(&amp;csp,
                                        "default-src 'self'; object-src 'none'; base-uri 'self'; frame-ancestors 'none'; script-src 'self' 'nonce-%s';",
                                        nonce,
                                )

                                // Dev: allow HMR / API calls to your dev servers via connect-src
                                if s.appEnv == "dev" </span><span class="cov0" title="0">{
                                        connect := make([]string, 0, 1+len(s.trustedOrigins)*2)
                                        connect = append(connect, "'self'")
                                        for _, o := range s.trustedOrigins </span><span class="cov0" title="0">{
                                                connect = append(connect, o)
                                                // Derive ws(s) URL from http(s) origin for dev tooling (HMR)
                                                if u, err := url.Parse(o); err == nil &amp;&amp; u.Host != "" </span><span class="cov0" title="0">{
                                                        switch u.Scheme </span>{
                                                        case "http":<span class="cov0" title="0">
                                                                connect = append(connect, "ws://"+u.Host)</span>
                                                        case "https":<span class="cov0" title="0">
                                                                connect = append(connect, "wss://"+u.Host)</span>
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">fmt.Fprintf(&amp;csp, " connect-src %s;", strings.Join(connect, " "))</span>
                                }

                                <span class="cov0" title="0">w.Header().Set(headerName, csp.String())
                                // stash nonce for templates
                                r = r.WithContext(WithNonce(r.Context(), nonce))</span>
                        }
                }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// No-store on sensitive endpoints
func (s *SecurityMiddleware) CacheControlForSensitive(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if s.isSensitiveEndpoint(r.URL.Path) </span><span class="cov0" title="0">{
                        w.Header().Set("Cache-Control", "no-store, max-age=0")
                        w.Header().Set("Pragma", "no-cache")
                        w.Header().Set("Expires", "0")
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
func (s *SecurityMiddleware) isSensitiveEndpoint(path string) bool <span class="cov0" title="0">{
        for _, p := range []string{"/auth/", "/profile", "/admin/"} </span><span class="cov0" title="0">{
                if strings.Contains(path, p) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CORS: exact-origin allowlist; credentials-safe; dynamic preflight
func (s *SecurityMiddleware) CORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                origin := r.Header.Get("Origin")
                allowed := s.isOriginAllowed(origin)

                // Methods/Headers
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, PATCH, DELETE, OPTIONS")

                // Echo requested headers for preflight if provided; else default
                if reqHdr := r.Header.Get("Access-Control-Request-Headers"); reqHdr != "" </span><span class="cov0" title="0">{
                        w.Header().Set("Access-Control-Allow-Headers", reqHdr)
                }</span> else<span class="cov0" title="0"> {
                        w.Header().Set("Access-Control-Allow-Headers", "Accept, Authorization, Content-Type, X-CSRF-Token, X-Requested-With")
                }</span>
                // Cache preflights (browsers cap this; 7200s is a common ceiling)
                <span class="cov0" title="0">w.Header().Set("Access-Control-Max-Age", "7200")

                if allowed </span><span class="cov0" title="0">{
                        w.Header().Set("Access-Control-Allow-Origin", origin) // reflect
                        w.Header().Set("Vary", "Origin")                      // cache safety for dynamic ACAO
                        w.Header().Set("Access-Control-Allow-Credentials", "true")
                }</span>

                // Preflight short-circuit
                <span class="cov0" title="0">if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        if !allowed </span><span class="cov0" title="0">{
                                http.Error(w, "CORS origin not allowed", http.StatusForbidden)
                                return
                        }</span>
                        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)
                        return</span>
                }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

type SecureCookieOptions struct {
        Name     string
        Value    string
        Path     string
        Domain   string
        MaxAge   int
        HttpOnly bool
        Secure   bool
        SameSite http.SameSite
}

func SetSecureCookie(w http.ResponseWriter, opts SecureCookieOptions) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     opts.Name,
                Value:    opts.Value,
                Path:     opts.Path,
                Domain:   opts.Domain,
                MaxAge:   opts.MaxAge,
                HttpOnly: opts.HttpOnly,
                Secure:   opts.Secure,
                SameSite: opts.SameSite,
        })
}</span>

// __Host- cookies must be Secure, Path=/, and have NO Domain attribute (HTTPS only)
func SetSecureAuthCookie(w http.ResponseWriter, name, value string, maxAge int) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "__Host-" + name,
                Value:    value,
                Path:     "/",
                MaxAge:   maxAge,
                HttpOnly: true,
                Secure:   true,
                SameSite: http.SameSiteLaxMode, // Lax is ergonomic &amp; CSRF-aware for same-site
        })
}</span>
func ClearSecureAuthCookie(w http.ResponseWriter, name string) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "__Host-" + name,
                Value:    "",
                Path:     "/",
                MaxAge:   -1,
                HttpOnly: true,
                Secure:   true,
                SameSite: http.SameSiteLaxMode,
        })
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type AdminInviteRepository interface {
        Create(ctx context.Context, invite *domain.AdminInvite) error
        GetByEmail(ctx context.Context, email string) (*domain.AdminInvite, error)
        Delete(ctx context.Context, id primitive.ObjectID) error
        DeleteExpired(ctx context.Context) error
}

type adminInviteRepository struct {
        collection *mongo.Collection
}

func NewAdminInviteRepository(db *database.MongoDB) AdminInviteRepository <span class="cov0" title="0">{
        return &amp;adminInviteRepository{
                collection: db.Database.Collection(database.AdminInvitesCollection),
        }
}</span>

func (r *adminInviteRepository) Create(ctx context.Context, invite *domain.AdminInvite) error <span class="cov0" title="0">{
        invite.ID = primitive.NewObjectID()
        _, err := r.collection.InsertOne(ctx, invite)
        return err
}</span>

func (r *adminInviteRepository) GetByEmail(ctx context.Context, email string) (*domain.AdminInvite, error) <span class="cov0" title="0">{
        var invite domain.AdminInvite
        filter := bson.M{
                "invitee_email": email,
                "expires_at":    bson.M{"$gt": time.Now()},
        }

        err := r.collection.FindOne(ctx, filter).Decode(&amp;invite)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;invite, nil</span>
}

func (r *adminInviteRepository) Delete(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        _, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
        return err
}</span>

func (r *adminInviteRepository) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{
        filter := bson.M{"expires_at": bson.M{"$lte": time.Now()}}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type CategoryRepository interface {
        Create(ctx context.Context, category *domain.Category) error
        GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Category, error)
        GetByName(ctx context.Context, name string) (*domain.Category, error)
        Update(ctx context.Context, category *domain.Category) error
        Delete(ctx context.Context, id primitive.ObjectID) error
        List(ctx context.Context, activeOnly bool, limit, offset int) ([]*domain.Category, error)
        SetActive(ctx context.Context, id primitive.ObjectID, isActive bool) error
}

type categoryRepository struct {
        collection *mongo.Collection
}

func NewCategoryRepository(db *database.MongoDB) CategoryRepository <span class="cov0" title="0">{
        return &amp;categoryRepository{
                collection: db.Database.Collection(database.CategoriesCollection),
        }
}</span>

func (r *categoryRepository) Create(ctx context.Context, category *domain.Category) error <span class="cov0" title="0">{
        category.ID = primitive.NewObjectID()
        category.CreatedAt = time.Now()
        category.UpdatedAt = time.Now()
        category.IsActive = true

        _, err := r.collection.InsertOne(ctx, category)
        return err
}</span>

func (r *categoryRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Category, error) <span class="cov0" title="0">{
        var category domain.Category
        err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;category)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;category, nil</span>
}

func (r *categoryRepository) GetByName(ctx context.Context, name string) (*domain.Category, error) <span class="cov0" title="0">{
        var category domain.Category
        err := r.collection.FindOne(ctx, bson.M{"name": name}).Decode(&amp;category)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;category, nil</span>
}

func (r *categoryRepository) Update(ctx context.Context, category *domain.Category) error <span class="cov0" title="0">{
        category.UpdatedAt = time.Now()
        filter := bson.M{"_id": category.ID}
        update := bson.M{"$set": category}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *categoryRepository) Delete(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        _, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
        return err
}</span>

func (r *categoryRepository) List(ctx context.Context, activeOnly bool, limit, offset int) ([]*domain.Category, error) <span class="cov0" title="0">{
        filter := bson.M{}
        if activeOnly </span><span class="cov0" title="0">{
                filter["is_active"] = true
        }</span>

        <span class="cov0" title="0">opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "name", Value: 1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var categories []*domain.Category
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var category domain.Category
                if err := cursor.Decode(&amp;category); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">categories = append(categories, &amp;category)</span>
        }

        <span class="cov0" title="0">return categories, cursor.Err()</span>
}

func (r *categoryRepository) SetActive(ctx context.Context, id primitive.ObjectID, isActive bool) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{
                "$set": bson.M{
                        "is_active":  isActive,
                        "updated_at": time.Now(),
                },
        }

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "context"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type DeviceRepository interface {
        Create(ctx context.Context, device *domain.Device) error
        GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Device, error)
        GetByStationID(ctx context.Context, stationID primitive.ObjectID) ([]*domain.Device, error)
        Update(ctx context.Context, device *domain.Device) error
        Delete(ctx context.Context, id primitive.ObjectID) error
        SetActive(ctx context.Context, id primitive.ObjectID, isActive bool) error
}

type deviceRepository struct {
        collection *mongo.Collection
}

func NewDeviceRepository(db *database.MongoDB) DeviceRepository <span class="cov0" title="0">{
        return &amp;deviceRepository{
                collection: db.Database.Collection(database.DevicesCollection),
        }
}</span>

func (r *deviceRepository) Create(ctx context.Context, device *domain.Device) error <span class="cov0" title="0">{
        device.ID = primitive.NewObjectID()
        device.IsActive = true
        _, err := r.collection.InsertOne(ctx, device)
        return err
}</span>

func (r *deviceRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Device, error) <span class="cov0" title="0">{
        var device domain.Device
        err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;device)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;device, nil</span>
}

func (r *deviceRepository) GetByStationID(ctx context.Context, stationID primitive.ObjectID) ([]*domain.Device, error) <span class="cov0" title="0">{
        filter := bson.M{"station_id": stationID}
        opts := options.Find().SetSort(bson.D{{Key: "name", Value: 1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var devices []*domain.Device
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var device domain.Device
                if err := cursor.Decode(&amp;device); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">devices = append(devices, &amp;device)</span>
        }

        <span class="cov0" title="0">return devices, cursor.Err()</span>
}

func (r *deviceRepository) Update(ctx context.Context, device *domain.Device) error <span class="cov0" title="0">{
        filter := bson.M{"_id": device.ID}
        update := bson.M{"$set": device}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *deviceRepository) Delete(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        _, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
        return err
}</span>

func (r *deviceRepository) SetActive(ctx context.Context, id primitive.ObjectID, isActive bool) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{"$set": bson.M{"is_active": isActive}}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type DeviceRequestRepository interface {
        Create(ctx context.Context, request *domain.DeviceRequest) error
        GetByID(ctx context.Context, id primitive.ObjectID) (*domain.DeviceRequest, error)
        GetByDeviceID(ctx context.Context, deviceID primitive.ObjectID) ([]*domain.DeviceRequest, error)
        GetPending(ctx context.Context, limit, offset int) ([]*domain.DeviceRequest, error)
        Approve(ctx context.Context, id primitive.ObjectID, approvedBy primitive.ObjectID) error
        Reject(ctx context.Context, id primitive.ObjectID, approvedBy primitive.ObjectID) error
        DeleteExpired(ctx context.Context) error
}

type deviceRequestRepository struct {
        collection *mongo.Collection
}

func NewDeviceRequestRepository(db *database.MongoDB) DeviceRequestRepository <span class="cov0" title="0">{
        return &amp;deviceRequestRepository{
                collection: db.Database.Collection(database.DeviceRequestsCollection),
        }
}</span>

func (r *deviceRequestRepository) Create(ctx context.Context, request *domain.DeviceRequest) error <span class="cov0" title="0">{
        request.ID = primitive.NewObjectID()
        request.Status = domain.DeviceRequestStatusPending
        request.CreatedAt = time.Now()

        _, err := r.collection.InsertOne(ctx, request)
        return err
}</span>

func (r *deviceRequestRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*domain.DeviceRequest, error) <span class="cov0" title="0">{
        var request domain.DeviceRequest
        err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;request, nil</span>
}

func (r *deviceRequestRepository) GetByDeviceID(ctx context.Context, deviceID primitive.ObjectID) ([]*domain.DeviceRequest, error) <span class="cov0" title="0">{
        filter := bson.M{"device_id": deviceID}
        opts := options.Find().SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var requests []*domain.DeviceRequest
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var request domain.DeviceRequest
                if err := cursor.Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">requests = append(requests, &amp;request)</span>
        }

        <span class="cov0" title="0">return requests, cursor.Err()</span>
}

func (r *deviceRequestRepository) GetPending(ctx context.Context, limit, offset int) ([]*domain.DeviceRequest, error) <span class="cov0" title="0">{
        filter := bson.M{
                "status":     domain.DeviceRequestStatusPending,
                "expires_at": bson.M{"$gt": time.Now()},
        }

        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: 1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var requests []*domain.DeviceRequest
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var request domain.DeviceRequest
                if err := cursor.Decode(&amp;request); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">requests = append(requests, &amp;request)</span>
        }

        <span class="cov0" title="0">return requests, cursor.Err()</span>
}

func (r *deviceRequestRepository) Approve(ctx context.Context, id primitive.ObjectID, approvedBy primitive.ObjectID) error <span class="cov0" title="0">{
        now := time.Now()
        filter := bson.M{"_id": id}
        update := bson.M{
                "$set": bson.M{
                        "status":      domain.DeviceRequestStatusApproved,
                        "approved_by": approvedBy,
                        "decided_at":  now,
                },
        }

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *deviceRequestRepository) Reject(ctx context.Context, id primitive.ObjectID, approvedBy primitive.ObjectID) error <span class="cov0" title="0">{
        now := time.Now()
        filter := bson.M{"_id": id}
        update := bson.M{
                "$set": bson.M{
                        "status":      domain.DeviceRequestStatusRejected,
                        "approved_by": approvedBy,
                        "decided_at":  now,
                },
        }

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *deviceRequestRepository) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{
        filter := bson.M{"expires_at": bson.M{"$lte": time.Now()}}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type InventoryLedgerRepository interface {
        Create(ctx context.Context, entry *domain.InventoryLedger) error
        GetByProductID(ctx context.Context, productID primitive.ObjectID, limit, offset int) ([]*domain.InventoryLedger, error)
        GetCurrentStock(ctx context.Context, productID primitive.ObjectID) (int, error)
        GetStockMovements(ctx context.Context, productID primitive.ObjectID, reason domain.InventoryReason, limit, offset int) ([]*domain.InventoryLedger, error)
}

type inventoryLedgerRepository struct {
        collection *mongo.Collection
}

func NewInventoryLedgerRepository(db *database.MongoDB) InventoryLedgerRepository <span class="cov0" title="0">{
        return &amp;inventoryLedgerRepository{
                collection: db.Database.Collection(database.InventoryLedgerCollection),
        }
}</span>

func (r *inventoryLedgerRepository) Create(ctx context.Context, entry *domain.InventoryLedger) error <span class="cov0" title="0">{
        entry.ID = primitive.NewObjectID()
        entry.Timestamp = time.Now()

        _, err := r.collection.InsertOne(ctx, entry)
        return err
}</span>

func (r *inventoryLedgerRepository) GetByProductID(ctx context.Context, productID primitive.ObjectID, limit, offset int) ([]*domain.InventoryLedger, error) <span class="cov0" title="0">{
        filter := bson.M{"product_id": productID}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "ts", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var entries []*domain.InventoryLedger
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var entry domain.InventoryLedger
                if err := cursor.Decode(&amp;entry); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">entries = append(entries, &amp;entry)</span>
        }

        <span class="cov0" title="0">return entries, cursor.Err()</span>
}

func (r *inventoryLedgerRepository) GetCurrentStock(ctx context.Context, productID primitive.ObjectID) (int, error) <span class="cov0" title="0">{
        pipeline := []bson.M{
                {"$match": bson.M{"product_id": productID}},
                {"$group": bson.M{
                        "_id":   nil,
                        "stock": bson.M{"$sum": "$delta"},
                }},
        }

        cursor, err := r.collection.Aggregate(ctx, pipeline)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        type result struct {
                Stock int `bson:"stock"`
        }

        var results []result
        if err := cursor.All(ctx, &amp;results); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">return results[0].Stock, nil</span>
}

func (r *inventoryLedgerRepository) GetStockMovements(ctx context.Context, productID primitive.ObjectID, reason domain.InventoryReason, limit, offset int) ([]*domain.InventoryLedger, error) <span class="cov0" title="0">{
        filter := bson.M{
                "product_id": productID,
                "reason":     reason,
        }

        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "ts", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var entries []*domain.InventoryLedger
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var entry domain.InventoryLedger
                if err := cursor.Decode(&amp;entry); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">entries = append(entries, &amp;entry)</span>
        }

        <span class="cov0" title="0">return entries, cursor.Err()</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type OrderRepository interface {
        Create(ctx context.Context, order *domain.Order) error
        GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Order, error)
        GetByCustomerID(ctx context.Context, customerID primitive.ObjectID, limit, offset int) ([]*domain.Order, error)
        GetByContactEmail(ctx context.Context, email string, limit, offset int) ([]*domain.Order, error)
        GetByStatus(ctx context.Context, status domain.OrderStatus, limit, offset int) ([]*domain.Order, error)
        Update(ctx context.Context, order *domain.Order) error
        UpdateStatus(ctx context.Context, id primitive.ObjectID, status domain.OrderStatus) error
        Delete(ctx context.Context, id primitive.ObjectID) error
        List(ctx context.Context, limit, offset int) ([]*domain.Order, error)
        GetRecent(ctx context.Context, limit int) ([]*domain.Order, error)
}

type orderRepository struct {
        collection *mongo.Collection
}

func NewOrderRepository(db *database.MongoDB) OrderRepository <span class="cov0" title="0">{
        return &amp;orderRepository{
                collection: db.Database.Collection(database.OrdersCollection),
        }
}</span>

func (r *orderRepository) Create(ctx context.Context, order *domain.Order) error <span class="cov0" title="0">{
        order.ID = primitive.NewObjectID()
        order.CreatedAt = time.Now()
        order.UpdatedAt = time.Now()
        order.Status = domain.OrderStatusPending

        _, err := r.collection.InsertOne(ctx, order)
        return err
}</span>

func (r *orderRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Order, error) <span class="cov0" title="0">{
        var order domain.Order
        err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;order)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;order, nil</span>
}

func (r *orderRepository) GetByCustomerID(ctx context.Context, customerID primitive.ObjectID, limit, offset int) ([]*domain.Order, error) <span class="cov0" title="0">{
        filter := bson.M{"customer_id": customerID}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var orders []*domain.Order
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var order domain.Order
                if err := cursor.Decode(&amp;order); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, &amp;order)</span>
        }

        <span class="cov0" title="0">return orders, cursor.Err()</span>
}

func (r *orderRepository) GetByContactEmail(ctx context.Context, email string, limit, offset int) ([]*domain.Order, error) <span class="cov0" title="0">{
        filter := bson.M{"contact_email": email}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var orders []*domain.Order
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var order domain.Order
                if err := cursor.Decode(&amp;order); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, &amp;order)</span>
        }

        <span class="cov0" title="0">return orders, cursor.Err()</span>
}

func (r *orderRepository) GetByStatus(ctx context.Context, status domain.OrderStatus, limit, offset int) ([]*domain.Order, error) <span class="cov0" title="0">{
        filter := bson.M{"status": status}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var orders []*domain.Order
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var order domain.Order
                if err := cursor.Decode(&amp;order); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, &amp;order)</span>
        }

        <span class="cov0" title="0">return orders, cursor.Err()</span>
}

func (r *orderRepository) Update(ctx context.Context, order *domain.Order) error <span class="cov0" title="0">{
        order.UpdatedAt = time.Now()
        filter := bson.M{"_id": order.ID}
        update := bson.M{"$set": order}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *orderRepository) UpdateStatus(ctx context.Context, id primitive.ObjectID, status domain.OrderStatus) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{
                "$set": bson.M{
                        "status":     status,
                        "updated_at": time.Now(),
                },
        }

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *orderRepository) Delete(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        _, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
        return err
}</span>

func (r *orderRepository) List(ctx context.Context, limit, offset int) ([]*domain.Order, error) <span class="cov0" title="0">{
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, bson.M{}, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var orders []*domain.Order
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var order domain.Order
                if err := cursor.Decode(&amp;order); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, &amp;order)</span>
        }

        <span class="cov0" title="0">return orders, cursor.Err()</span>
}

func (r *orderRepository) GetRecent(ctx context.Context, limit int) ([]*domain.Order, error) <span class="cov0" title="0">{
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, bson.M{}, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var orders []*domain.Order
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var order domain.Order
                if err := cursor.Decode(&amp;order); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, &amp;order)</span>
        }

        <span class="cov0" title="0">return orders, cursor.Err()</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type OrderItemRepository interface {
        Create(ctx context.Context, item *domain.OrderItem) error
        CreateBatch(ctx context.Context, items []*domain.OrderItem) error
        GetByID(ctx context.Context, id primitive.ObjectID) (*domain.OrderItem, error)
        GetByOrderID(ctx context.Context, orderID primitive.ObjectID) ([]*domain.OrderItem, error)
        GetUnredeemedByOrderID(ctx context.Context, orderID primitive.ObjectID) ([]*domain.OrderItem, error)
        GetByProductID(ctx context.Context, productID primitive.ObjectID, unredeemedOnly bool) ([]*domain.OrderItem, error)
        GetByParentItemID(ctx context.Context, parentItemID primitive.ObjectID) ([]*domain.OrderItem, error)
        Update(ctx context.Context, item *domain.OrderItem) error
        MarkAsRedeemed(ctx context.Context, id primitive.ObjectID, stationID, deviceID primitive.ObjectID) error
        Delete(ctx context.Context, id primitive.ObjectID) error
        DeleteByOrderID(ctx context.Context, orderID primitive.ObjectID) error
        GetRedeemedByStation(ctx context.Context, stationID primitive.ObjectID, limit, offset int) ([]*domain.OrderItem, error)
        GetRedeemedByDevice(ctx context.Context, deviceID primitive.ObjectID, limit, offset int) ([]*domain.OrderItem, error)
}

type orderItemRepository struct {
        collection *mongo.Collection
}

func NewOrderItemRepository(db *database.MongoDB) OrderItemRepository <span class="cov0" title="0">{
        return &amp;orderItemRepository{
                collection: db.Database.Collection(database.OrderItemsCollection),
        }
}</span>

func (r *orderItemRepository) Create(ctx context.Context, item *domain.OrderItem) error <span class="cov0" title="0">{
        item.ID = primitive.NewObjectID()
        item.IsRedeemed = false

        _, err := r.collection.InsertOne(ctx, item)
        return err
}</span>

func (r *orderItemRepository) CreateBatch(ctx context.Context, items []*domain.OrderItem) error <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">docs := make([]interface{}, len(items))
        for i, item := range items </span><span class="cov0" title="0">{
                item.ID = primitive.NewObjectID()
                item.IsRedeemed = false
                docs[i] = item
        }</span>

        <span class="cov0" title="0">_, err := r.collection.InsertMany(ctx, docs)
        return err</span>
}

func (r *orderItemRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*domain.OrderItem, error) <span class="cov0" title="0">{
        var item domain.OrderItem
        err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;item)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;item, nil</span>
}

func (r *orderItemRepository) GetByOrderID(ctx context.Context, orderID primitive.ObjectID) ([]*domain.OrderItem, error) <span class="cov0" title="0">{
        filter := bson.M{"order_id": orderID}
        opts := options.Find().SetSort(bson.D{{Key: "parent_item_id", Value: 1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var items []*domain.OrderItem
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var item domain.OrderItem
                if err := cursor.Decode(&amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, &amp;item)</span>
        }

        <span class="cov0" title="0">return items, cursor.Err()</span>
}

func (r *orderItemRepository) GetUnredeemedByOrderID(ctx context.Context, orderID primitive.ObjectID) ([]*domain.OrderItem, error) <span class="cov0" title="0">{
        filter := bson.M{
                "order_id":    orderID,
                "is_redeemed": false,
        }

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var items []*domain.OrderItem
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var item domain.OrderItem
                if err := cursor.Decode(&amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, &amp;item)</span>
        }

        <span class="cov0" title="0">return items, cursor.Err()</span>
}

func (r *orderItemRepository) GetByProductID(ctx context.Context, productID primitive.ObjectID, unredeemedOnly bool) ([]*domain.OrderItem, error) <span class="cov0" title="0">{
        filter := bson.M{"product_id": productID}
        if unredeemedOnly </span><span class="cov0" title="0">{
                filter["is_redeemed"] = false
        }</span>

        <span class="cov0" title="0">opts := options.Find().SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var items []*domain.OrderItem
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var item domain.OrderItem
                if err := cursor.Decode(&amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, &amp;item)</span>
        }

        <span class="cov0" title="0">return items, cursor.Err()</span>
}

func (r *orderItemRepository) GetByParentItemID(ctx context.Context, parentItemID primitive.ObjectID) ([]*domain.OrderItem, error) <span class="cov0" title="0">{
        filter := bson.M{"parent_item_id": parentItemID}

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var items []*domain.OrderItem
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var item domain.OrderItem
                if err := cursor.Decode(&amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, &amp;item)</span>
        }

        <span class="cov0" title="0">return items, cursor.Err()</span>
}

func (r *orderItemRepository) Update(ctx context.Context, item *domain.OrderItem) error <span class="cov0" title="0">{
        filter := bson.M{"_id": item.ID}
        update := bson.M{"$set": item}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *orderItemRepository) MarkAsRedeemed(ctx context.Context, id primitive.ObjectID, stationID, deviceID primitive.ObjectID) error <span class="cov0" title="0">{
        now := time.Now()
        filter := bson.M{"_id": id}
        update := bson.M{
                "$set": bson.M{
                        "is_redeemed":         true,
                        "redeemed_at":         now,
                        "redeemed_station_id": stationID,
                        "redeemed_device_id":  deviceID,
                },
        }

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *orderItemRepository) Delete(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        _, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
        return err
}</span>

func (r *orderItemRepository) DeleteByOrderID(ctx context.Context, orderID primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"order_id": orderID}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>

func (r *orderItemRepository) GetRedeemedByStation(ctx context.Context, stationID primitive.ObjectID, limit, offset int) ([]*domain.OrderItem, error) <span class="cov0" title="0">{
        filter := bson.M{
                "redeemed_station_id": stationID,
                "is_redeemed":         true,
        }

        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "redeemed_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var items []*domain.OrderItem
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var item domain.OrderItem
                if err := cursor.Decode(&amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, &amp;item)</span>
        }

        <span class="cov0" title="0">return items, cursor.Err()</span>
}

func (r *orderItemRepository) GetRedeemedByDevice(ctx context.Context, deviceID primitive.ObjectID, limit, offset int) ([]*domain.OrderItem, error) <span class="cov0" title="0">{
        filter := bson.M{
                "redeemed_device_id": deviceID,
                "is_redeemed":        true,
        }

        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "redeemed_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var items []*domain.OrderItem
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var item domain.OrderItem
                if err := cursor.Decode(&amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, &amp;item)</span>
        }

        <span class="cov0" title="0">return items, cursor.Err()</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type OTPTokenRepository interface {
        Create(ctx context.Context, token *domain.OTPToken) error
        GetLatestByUserAndType(ctx context.Context, userID primitive.ObjectID, tokenType domain.TokenType) (*domain.OTPToken, error)
        MarkAsUsed(ctx context.Context, id primitive.ObjectID) error
        IncrementAttempts(ctx context.Context, id primitive.ObjectID) error
        DeleteExpired(ctx context.Context) error
        DeleteByUserID(ctx context.Context, userID primitive.ObjectID) error
}

type otpTokenRepository struct {
        collection *mongo.Collection
}

func NewOTPTokenRepository(db *database.MongoDB) OTPTokenRepository <span class="cov0" title="0">{
        return &amp;otpTokenRepository{
                collection: db.Database.Collection(database.OTPTokensCollection),
        }
}</span>

func (r *otpTokenRepository) Create(ctx context.Context, token *domain.OTPToken) error <span class="cov0" title="0">{
        token.ID = primitive.NewObjectID()
        token.CreatedAt = time.Now()
        token.Attempts = 0

        _, err := r.collection.InsertOne(ctx, token)
        return err
}</span>

func (r *otpTokenRepository) GetLatestByUserAndType(ctx context.Context, userID primitive.ObjectID, tokenType domain.TokenType) (*domain.OTPToken, error) <span class="cov0" title="0">{
        filter := bson.M{
                "user_id":    userID,
                "type":       tokenType,
                "used_at":    nil,
                "expires_at": bson.M{"$gt": time.Now()},
        }

        opts := options.FindOne().SetSort(bson.D{{Key: "created_at", Value: -1}})

        var token domain.OTPToken
        err := r.collection.FindOne(ctx, filter, opts).Decode(&amp;token)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;token, nil</span>
}

func (r *otpTokenRepository) MarkAsUsed(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{"$set": bson.M{"used_at": time.Now()}}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *otpTokenRepository) IncrementAttempts(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{"$inc": bson.M{"attempts": 1}}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *otpTokenRepository) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{
        filter := bson.M{"expires_at": bson.M{"$lte": time.Now()}}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>

func (r *otpTokenRepository) DeleteByUserID(ctx context.Context, userID primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"user_id": userID}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type ProductRepository interface {
        Create(ctx context.Context, product *domain.Product) error
        GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Product, error)
        GetByCategoryID(ctx context.Context, categoryID primitive.ObjectID, activeOnly bool, limit, offset int) ([]*domain.Product, error)
        Update(ctx context.Context, product *domain.Product) error
        Delete(ctx context.Context, id primitive.ObjectID) error
        Search(ctx context.Context, query string, limit, offset int) ([]*domain.Product, error)
        SetActive(ctx context.Context, id primitive.ObjectID, isActive bool) error
        GetByType(ctx context.Context, productType domain.ProductType, limit, offset int) ([]*domain.Product, error)
}

type productRepository struct {
        collection *mongo.Collection
}

func NewProductRepository(db *database.MongoDB) ProductRepository <span class="cov0" title="0">{
        return &amp;productRepository{
                collection: db.Database.Collection(database.ProductsCollection),
        }
}</span>

func (r *productRepository) Create(ctx context.Context, product *domain.Product) error <span class="cov0" title="0">{
        product.ID = primitive.NewObjectID()
        product.CreatedAt = time.Now()
        product.UpdatedAt = time.Now()
        product.IsActive = true

        _, err := r.collection.InsertOne(ctx, product)
        return err
}</span>

func (r *productRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Product, error) <span class="cov0" title="0">{
        var product domain.Product
        err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;product)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;product, nil</span>
}

func (r *productRepository) GetByCategoryID(ctx context.Context, categoryID primitive.ObjectID, activeOnly bool, limit, offset int) ([]*domain.Product, error) <span class="cov0" title="0">{
        filter := bson.M{"category_id": categoryID}
        if activeOnly </span><span class="cov0" title="0">{
                filter["is_active"] = true
        }</span>

        <span class="cov0" title="0">opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "name", Value: 1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var products []*domain.Product
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var product domain.Product
                if err := cursor.Decode(&amp;product); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">products = append(products, &amp;product)</span>
        }

        <span class="cov0" title="0">return products, cursor.Err()</span>
}

func (r *productRepository) Update(ctx context.Context, product *domain.Product) error <span class="cov0" title="0">{
        product.UpdatedAt = time.Now()
        filter := bson.M{"_id": product.ID}
        update := bson.M{"$set": product}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *productRepository) Delete(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        _, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
        return err
}</span>

func (r *productRepository) Search(ctx context.Context, query string, limit, offset int) ([]*domain.Product, error) <span class="cov0" title="0">{
        filter := bson.M{
                "name":      bson.M{"$regex": query, "$options": "i"},
                "is_active": true,
        }

        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "name", Value: 1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var products []*domain.Product
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var product domain.Product
                if err := cursor.Decode(&amp;product); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">products = append(products, &amp;product)</span>
        }

        <span class="cov0" title="0">return products, cursor.Err()</span>
}

func (r *productRepository) SetActive(ctx context.Context, id primitive.ObjectID, isActive bool) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{
                "$set": bson.M{
                        "is_active":  isActive,
                        "updated_at": time.Now(),
                },
        }

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *productRepository) GetByType(ctx context.Context, productType domain.ProductType, limit, offset int) ([]*domain.Product, error) <span class="cov0" title="0">{
        filter := bson.M{
                "type":      productType,
                "is_active": true,
        }

        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "name", Value: 1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var products []*domain.Product
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var product domain.Product
                if err := cursor.Decode(&amp;product); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">products = append(products, &amp;product)</span>
        }

        <span class="cov0" title="0">return products, cursor.Err()</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "context"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type ProductBundleComponentRepository interface {
        Create(ctx context.Context, component *domain.ProductBundleComponent) error
        GetByBundleID(ctx context.Context, bundleID primitive.ObjectID) ([]*domain.ProductBundleComponent, error)
        Update(ctx context.Context, component *domain.ProductBundleComponent) error
        Delete(ctx context.Context, bundleID, componentID primitive.ObjectID) error
        DeleteByBundleID(ctx context.Context, bundleID primitive.ObjectID) error
}

type productBundleComponentRepository struct {
        collection *mongo.Collection
}

func NewProductBundleComponentRepository(db *database.MongoDB) ProductBundleComponentRepository <span class="cov0" title="0">{
        return &amp;productBundleComponentRepository{
                collection: db.Database.Collection(database.ProductBundleComponentsCollection),
        }
}</span>

func (r *productBundleComponentRepository) Create(ctx context.Context, component *domain.ProductBundleComponent) error <span class="cov0" title="0">{
        _, err := r.collection.InsertOne(ctx, component)
        return err
}</span>

func (r *productBundleComponentRepository) GetByBundleID(ctx context.Context, bundleID primitive.ObjectID) ([]*domain.ProductBundleComponent, error) <span class="cov0" title="0">{
        filter := bson.M{"bundle_id": bundleID}

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var components []*domain.ProductBundleComponent
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var component domain.ProductBundleComponent
                if err := cursor.Decode(&amp;component); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">components = append(components, &amp;component)</span>
        }

        <span class="cov0" title="0">return components, cursor.Err()</span>
}

func (r *productBundleComponentRepository) Update(ctx context.Context, component *domain.ProductBundleComponent) error <span class="cov0" title="0">{
        filter := bson.M{
                "bundle_id":            component.BundleID,
                "component_product_id": component.ComponentProductID,
        }
        update := bson.M{"$set": component}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *productBundleComponentRepository) Delete(ctx context.Context, bundleID, componentID primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{
                "bundle_id":            bundleID,
                "component_product_id": componentID,
        }
        _, err := r.collection.DeleteOne(ctx, filter)
        return err
}</span>

func (r *productBundleComponentRepository) DeleteByBundleID(ctx context.Context, bundleID primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"bundle_id": bundleID}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package repository

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type RefreshTokenRepository interface {
        Create(ctx context.Context, token *domain.RefreshToken) error
        CreateWithPlainToken(ctx context.Context, token *domain.RefreshToken, plainToken string) error
        GetByTokenHash(ctx context.Context, tokenHash string) (*domain.RefreshToken, error)
        GetValidTokenForUser(ctx context.Context, plainToken string) (*domain.RefreshToken, error)
        UpdateLastUsed(ctx context.Context, id primitive.ObjectID) error
        RevokeByFamilyID(ctx context.Context, familyID string, reason string) error
        RevokeByID(ctx context.Context, id primitive.ObjectID, reason string) error
        RevokeByHash(ctx context.Context, tokenHash string) error
        RevokeByClientID(ctx context.Context, userID primitive.ObjectID, clientID string, reason string) error
        DeleteExpired(ctx context.Context) error
        DeleteByUserID(ctx context.Context, userID primitive.ObjectID) error
        GetActiveByUserID(ctx context.Context, userID primitive.ObjectID) ([]*domain.RefreshToken, error)
}

type refreshTokenRepository struct {
        collection *mongo.Collection
}

func NewRefreshTokenRepository(db *database.MongoDB) RefreshTokenRepository <span class="cov0" title="0">{
        return &amp;refreshTokenRepository{
                collection: db.Database.Collection(database.RefreshTokensCollection),
        }
}</span>

func (r *refreshTokenRepository) Create(ctx context.Context, token *domain.RefreshToken) error <span class="cov0" title="0">{
        token.ID = primitive.NewObjectID()
        token.IssuedAt = time.Now()
        token.LastUsedAt = time.Now()
        token.IsRevoked = false

        _, err := r.collection.InsertOne(ctx, token)
        return err
}</span>

func (r *refreshTokenRepository) GetByTokenHash(ctx context.Context, tokenHash string) (*domain.RefreshToken, error) <span class="cov0" title="0">{
        filter := bson.M{
                "token_hash": tokenHash,
                "is_revoked": false,
                "expires_at": bson.M{"$gt": time.Now()},
        }

        var token domain.RefreshToken
        err := r.collection.FindOne(ctx, filter).Decode(&amp;token)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;token, nil</span>
}

func (r *refreshTokenRepository) UpdateLastUsed(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{"$set": bson.M{"last_used_at": time.Now()}}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *refreshTokenRepository) RevokeByFamilyID(ctx context.Context, familyID string, reason string) error <span class="cov0" title="0">{
        filter := bson.M{"family_id": familyID}
        update := bson.M{
                "$set": bson.M{
                        "is_revoked":     true,
                        "revoked_reason": reason,
                },
        }

        _, err := r.collection.UpdateMany(ctx, filter, update)
        return err
}</span>

func (r *refreshTokenRepository) RevokeByID(ctx context.Context, id primitive.ObjectID, reason string) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{
                "$set": bson.M{
                        "is_revoked":     true,
                        "revoked_reason": reason,
                },
        }

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *refreshTokenRepository) DeleteExpired(ctx context.Context) error <span class="cov0" title="0">{
        filter := bson.M{"expires_at": bson.M{"$lte": time.Now()}}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>

func (r *refreshTokenRepository) DeleteByUserID(ctx context.Context, userID primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"user_id": userID}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>

func (r *refreshTokenRepository) GetActiveByUserID(ctx context.Context, userID primitive.ObjectID) ([]*domain.RefreshToken, error) <span class="cov0" title="0">{
        filter := bson.M{
                "user_id":    userID,
                "is_revoked": false,
                "expires_at": bson.M{"$gt": time.Now()},
        }

        opts := options.Find().SetSort(bson.D{{Key: "last_used_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var tokens []*domain.RefreshToken
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var token domain.RefreshToken
                if err := cursor.Decode(&amp;token); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">tokens = append(tokens, &amp;token)</span>
        }

        <span class="cov0" title="0">return tokens, cursor.Err()</span>
}

func (r *refreshTokenRepository) GetValidTokenForUser(ctx context.Context, plainToken string) (*domain.RefreshToken, error) <span class="cov0" title="0">{
        // Hash the plain token to compare with stored hashes
        tokenHash := hashRefreshToken(plainToken)

        filter := bson.M{
                "token_hash": tokenHash,
                "is_revoked": false,
                "expires_at": bson.M{"$gt": time.Now()},
        }

        var token domain.RefreshToken
        err := r.collection.FindOne(ctx, filter).Decode(&amp;token)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, domain.ErrRefreshTokenNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;token, nil</span>
}

func (r *refreshTokenRepository) RevokeByHash(ctx context.Context, tokenHash string) error <span class="cov0" title="0">{
        filter := bson.M{"token_hash": tokenHash}
        update := bson.M{
                "$set": bson.M{
                        "is_revoked":     true,
                        "revoked_reason": "token_rotation",
                },
        }

        result, err := r.collection.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return domain.ErrRefreshTokenNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *refreshTokenRepository) CreateWithPlainToken(ctx context.Context, token *domain.RefreshToken, plainToken string) error <span class="cov0" title="0">{
        token.ID = primitive.NewObjectID()
        token.IssuedAt = time.Now()
        token.LastUsedAt = time.Now()
        token.IsRevoked = false
        token.TokenHash = hashRefreshToken(plainToken)

        _, err := r.collection.InsertOne(ctx, token)
        return err
}</span>

func (r *refreshTokenRepository) RevokeByClientID(ctx context.Context, userID primitive.ObjectID, clientID string, reason string) error <span class="cov0" title="0">{
        filter := bson.M{
                "user_id":    userID,
                "client_id":  clientID,
                "is_revoked": false,
        }
        update := bson.M{
                "$set": bson.M{
                        "is_revoked":     true,
                        "revoked_reason": reason,
                },
        }

        _, err := r.collection.UpdateMany(ctx, filter, update)
        return err
}</span>

func hashRefreshToken(plainToken string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(plainToken))
        return hex.EncodeToString(hash[:])
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type StationRepository interface {
        Create(ctx context.Context, station *domain.Station) error
        GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Station, error)
        GetByName(ctx context.Context, name string) (*domain.Station, error)
        Update(ctx context.Context, station *domain.Station) error
        Delete(ctx context.Context, id primitive.ObjectID) error
        List(ctx context.Context, limit, offset int) ([]*domain.Station, error)
        ListByStatus(ctx context.Context, status domain.StationStatus, limit, offset int) ([]*domain.Station, error)
        ApproveStation(ctx context.Context, stationID, adminID primitive.ObjectID) error
        RejectStation(ctx context.Context, stationID, adminID primitive.ObjectID, reason string) error
}

type stationRepository struct {
        collection *mongo.Collection
}

func NewStationRepository(db *database.MongoDB) StationRepository <span class="cov0" title="0">{
        return &amp;stationRepository{
                collection: db.Database.Collection(database.StationsCollection),
        }
}</span>

func (r *stationRepository) Create(ctx context.Context, station *domain.Station) error <span class="cov0" title="0">{
        station.ID = primitive.NewObjectID()
        station.CreatedAt = time.Now()
        station.UpdatedAt = time.Now()
        if station.Status == "" </span><span class="cov0" title="0">{
                station.Status = domain.StationStatusPending
        }</span>
        <span class="cov0" title="0">_, err := r.collection.InsertOne(ctx, station)
        return err</span>
}

func (r *stationRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*domain.Station, error) <span class="cov0" title="0">{
        var station domain.Station
        err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;station)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;station, nil</span>
}

func (r *stationRepository) GetByName(ctx context.Context, name string) (*domain.Station, error) <span class="cov0" title="0">{
        var station domain.Station
        err := r.collection.FindOne(ctx, bson.M{"name": name}).Decode(&amp;station)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;station, nil</span>
}

func (r *stationRepository) Update(ctx context.Context, station *domain.Station) error <span class="cov0" title="0">{
        filter := bson.M{"_id": station.ID}
        station.UpdatedAt = time.Now()
        update := bson.M{"$set": station}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *stationRepository) Delete(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        _, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
        return err
}</span>

func (r *stationRepository) List(ctx context.Context, limit, offset int) ([]*domain.Station, error) <span class="cov0" title="0">{
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "name", Value: 1}})

        cursor, err := r.collection.Find(ctx, bson.M{}, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var stations []*domain.Station
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var station domain.Station
                if err := cursor.Decode(&amp;station); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">stations = append(stations, &amp;station)</span>
        }

        <span class="cov0" title="0">return stations, cursor.Err()</span>
}

func (r *stationRepository) ListByStatus(ctx context.Context, status domain.StationStatus, limit, offset int) ([]*domain.Station, error) <span class="cov0" title="0">{
        filter := bson.M{"status": status}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var stations []*domain.Station
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var station domain.Station
                if err := cursor.Decode(&amp;station); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">stations = append(stations, &amp;station)</span>
        }

        <span class="cov0" title="0">return stations, cursor.Err()</span>
}


func (r *stationRepository) ApproveStation(ctx context.Context, stationID, adminID primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{
                "_id": stationID,
                "status": domain.StationStatusPending,
        }
        now := time.Now()
        update := bson.M{
                "$set": bson.M{
                        "status":      domain.StationStatusApproved,
                        "approved_by": adminID,
                        "approved_at": now,
                        "updated_at":  now,
                },
                "$unset": bson.M{
                        "rejected_by":      "",
                        "rejected_at":      "",
                        "rejection_reason": "",
                },
        }

        result, err := r.collection.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return mongo.ErrNoDocuments
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *stationRepository) RejectStation(ctx context.Context, stationID, adminID primitive.ObjectID, reason string) error <span class="cov0" title="0">{
        filter := bson.M{
                "_id": stationID,
                "status": domain.StationStatusPending,
        }
        now := time.Now()
        update := bson.M{
                "$set": bson.M{
                        "status":           domain.StationStatusRejected,
                        "rejected_by":      adminID,
                        "rejected_at":      now,
                        "rejection_reason": reason,
                        "updated_at":       now,
                },
                "$unset": bson.M{
                        "approved_by": "",
                        "approved_at": "",
                },
        }

        result, err := r.collection.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return mongo.ErrNoDocuments
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package repository

import (
        "context"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type StationProductRepository interface {
        Create(ctx context.Context, sp *domain.StationProduct) error
        GetByStationID(ctx context.Context, stationID primitive.ObjectID) ([]*domain.StationProduct, error)
        GetByProductID(ctx context.Context, productID primitive.ObjectID) ([]*domain.StationProduct, error)
        Delete(ctx context.Context, stationID, productID primitive.ObjectID) error
        DeleteByStationID(ctx context.Context, stationID primitive.ObjectID) error
        DeleteByProductID(ctx context.Context, productID primitive.ObjectID) error
}

type stationProductRepository struct {
        collection *mongo.Collection
}

func NewStationProductRepository(db *database.MongoDB) StationProductRepository <span class="cov0" title="0">{
        return &amp;stationProductRepository{
                collection: db.Database.Collection(database.StationProductsCollection),
        }
}</span>

func (r *stationProductRepository) Create(ctx context.Context, sp *domain.StationProduct) error <span class="cov0" title="0">{
        _, err := r.collection.InsertOne(ctx, sp)
        return err
}</span>

func (r *stationProductRepository) GetByStationID(ctx context.Context, stationID primitive.ObjectID) ([]*domain.StationProduct, error) <span class="cov0" title="0">{
        filter := bson.M{"station_id": stationID}

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var stationProducts []*domain.StationProduct
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var sp domain.StationProduct
                if err := cursor.Decode(&amp;sp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">stationProducts = append(stationProducts, &amp;sp)</span>
        }

        <span class="cov0" title="0">return stationProducts, cursor.Err()</span>
}

func (r *stationProductRepository) GetByProductID(ctx context.Context, productID primitive.ObjectID) ([]*domain.StationProduct, error) <span class="cov0" title="0">{
        filter := bson.M{"product_id": productID}

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var stationProducts []*domain.StationProduct
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var sp domain.StationProduct
                if err := cursor.Decode(&amp;sp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">stationProducts = append(stationProducts, &amp;sp)</span>
        }

        <span class="cov0" title="0">return stationProducts, cursor.Err()</span>
}

func (r *stationProductRepository) Delete(ctx context.Context, stationID, productID primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{
                "station_id": stationID,
                "product_id": productID,
        }
        _, err := r.collection.DeleteOne(ctx, filter)
        return err
}</span>

func (r *stationProductRepository) DeleteByStationID(ctx context.Context, stationID primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"station_id": stationID}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>

func (r *stationProductRepository) DeleteByProductID(ctx context.Context, productID primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"product_id": productID}
        _, err := r.collection.DeleteMany(ctx, filter)
        return err
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package repository

import (
        "context"
        "time"

        "backend/internal/database"
        "backend/internal/domain"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type UserRepository interface {
        Create(ctx context.Context, user *domain.User) error
        GetByID(ctx context.Context, id primitive.ObjectID) (*domain.User, error)
        GetByEmail(ctx context.Context, email string) (*domain.User, error)
        Update(ctx context.Context, user *domain.User) error
        Delete(ctx context.Context, id primitive.ObjectID) error
        List(ctx context.Context, limit, offset int) ([]*domain.User, error)
        ListCustomers(ctx context.Context, limit, offset int) ([]*domain.User, error)
        CountCustomers(ctx context.Context) (int, error)
        Disable(ctx context.Context, id primitive.ObjectID, reason string) error
        Enable(ctx context.Context, id primitive.ObjectID) error
}

type userRepository struct {
        collection *mongo.Collection
}

func NewUserRepository(db *database.MongoDB) UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{
                collection: db.Database.Collection(database.UsersCollection),
        }
}</span>

func (r *userRepository) Create(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        user.ID = primitive.NewObjectID()
        user.CreatedAt = time.Now()
        user.UpdatedAt = time.Now()

        _, err := r.collection.InsertOne(ctx, user)
        return err
}</span>

func (r *userRepository) GetByID(ctx context.Context, id primitive.ObjectID) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        err := r.collection.FindOne(ctx, bson.M{"_id": id}).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) GetByEmail(ctx context.Context, email string) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        err := r.collection.FindOne(ctx, bson.M{"email": email}).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) Update(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        user.UpdatedAt = time.Now()
        filter := bson.M{"_id": user.ID}
        update := bson.M{"$set": user}

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *userRepository) Delete(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        _, err := r.collection.DeleteOne(ctx, bson.M{"_id": id})
        return err
}</span>

func (r *userRepository) List(ctx context.Context, limit, offset int) ([]*domain.User, error) <span class="cov0" title="0">{
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, bson.M{}, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var users []*domain.User
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var user domain.User
                if err := cursor.Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">users = append(users, &amp;user)</span>
        }

        <span class="cov0" title="0">return users, cursor.Err()</span>
}

func (r *userRepository) Disable(ctx context.Context, id primitive.ObjectID, reason string) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{
                "$set": bson.M{
                        "is_disabled":     true,
                        "disabled_reason": reason,
                        "updated_at":      time.Now(),
                },
        }

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *userRepository) Enable(ctx context.Context, id primitive.ObjectID) error <span class="cov0" title="0">{
        filter := bson.M{"_id": id}
        update := bson.M{
                "$set": bson.M{
                        "is_disabled": false,
                        "updated_at":  time.Now(),
                },
                "$unset": bson.M{
                        "disabled_reason": "",
                },
        }

        _, err := r.collection.UpdateOne(ctx, filter, update)
        return err
}</span>

func (r *userRepository) ListCustomers(ctx context.Context, limit, offset int) ([]*domain.User, error) <span class="cov0" title="0">{
        filter := bson.M{"role": domain.UserRoleCustomer}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var users []*domain.User
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var user domain.User
                if err := cursor.Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">users = append(users, &amp;user)</span>
        }

        <span class="cov0" title="0">return users, cursor.Err()</span>
}

func (r *userRepository) CountCustomers(ctx context.Context) (int, error) <span class="cov0" title="0">{
        filter := bson.M{"role": domain.UserRoleCustomer}
        count, err := r.collection.CountDocuments(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return int(count), nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package response

import (
        "encoding/json"
        "net/http"

        "go.uber.org/zap"
)

type ErrorResponse struct {
        Error   bool   `json:"error"`
        Message string `json:"message"`
        Status  int    `json:"status"`
}

func WriteJSON(w http.ResponseWriter, status int, data any) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to encode response", zap.Error(err))
        }</span>
}

func WriteError(w http.ResponseWriter, status int, message string) <span class="cov0" title="0">{
        WriteJSON(w, status, ErrorResponse{Error: true, Message: message, Status: status})
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "time"

        "backend/internal/domain"
        "backend/internal/repository"

        "go.mongodb.org/mongo-driver/bson/primitive"
)

// AdminService defines the admin management service interface
type AdminService interface {
        ListCustomers(ctx context.Context, limit, offset int) (*ListCustomersResponse, error)
        BanCustomer(ctx context.Context, customerID string, req BanCustomerRequest) (*BanCustomerResponse, error)
        DeleteCustomer(ctx context.Context, customerID string) (*DeleteCustomerResponse, error)
        InviteAdmin(ctx context.Context, adminID string, req InviteAdminRequest) (*InviteAdminResponse, error)
}

// Request/Response types
type Customer struct {
        ID         string `json:"id"`
        Email      string `json:"email"`
        IsVerified bool   `json:"is_verified"`
        IsDisabled bool   `json:"is_disabled"`
        CreatedAt  string `json:"created_at"`
}

type ListCustomersResponse struct {
        Customers []Customer `json:"customers"`
        Total     int        `json:"total"`
}

type BanCustomerRequest struct {
        Reason string `json:"reason" validate:"required"`
}

type BanCustomerResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type DeleteCustomerResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type InviteAdminRequest struct {
        Email string `json:"email" validate:"required,email"`
}

type InviteAdminResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type adminService struct {
        userRepo        repository.UserRepository
        adminInviteRepo repository.AdminInviteRepository
        emailService    EmailService
}

func NewAdminService(
        userRepo repository.UserRepository,
        adminInviteRepo repository.AdminInviteRepository,
        emailService EmailService,
) AdminService <span class="cov0" title="0">{
        return &amp;adminService{
                userRepo:        userRepo,
                adminInviteRepo: adminInviteRepo,
                emailService:    emailService,
        }
}</span>

func (s *adminService) ListCustomers(ctx context.Context, limit, offset int) (*ListCustomersResponse, error) <span class="cov0" title="0">{
        // Set default limit if not provided
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100 // Cap at 100 to prevent abuse
        }</span>

        <span class="cov0" title="0">users, err := s.userRepo.ListCustomers(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list customers: %w", err)
        }</span>

        <span class="cov0" title="0">customers := make([]Customer, len(users))
        for i, user := range users </span><span class="cov0" title="0">{
                customers[i] = Customer{
                        ID:         user.ID.Hex(),
                        Email:      user.Email,
                        IsVerified: user.IsVerified,
                        IsDisabled: user.IsDisabled,
                        CreatedAt:  user.CreatedAt.Format(time.RFC3339),
                }
        }</span>

        // Get total count for pagination
        <span class="cov0" title="0">totalCount, err := s.userRepo.CountCustomers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count customers: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ListCustomersResponse{
                Customers: customers,
                Total:     totalCount,
        }, nil</span>
}

func (s *adminService) BanCustomer(ctx context.Context, customerID string, req BanCustomerRequest) (*BanCustomerResponse, error) <span class="cov0" title="0">{
        // Convert customerID to ObjectID
        objectID, err := primitive.ObjectIDFromHex(customerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid customer ID format")
        }</span>

        // Get customer to verify it exists and is a customer
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get customer: %w", err)
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("customer not found")
        }</span>

        // Ensure user is a customer (not admin)
        <span class="cov0" title="0">if user.Role != domain.UserRoleCustomer </span><span class="cov0" title="0">{
                return nil, errors.New("can only ban customer accounts")
        }</span>

        // Check if already banned
        <span class="cov0" title="0">if user.IsDisabled </span><span class="cov0" title="0">{
                return nil, errors.New("customer is already banned")
        }</span>

        // Ban the customer
        <span class="cov0" title="0">if err := s.userRepo.Disable(ctx, objectID, req.Reason); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ban customer: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;BanCustomerResponse{
                Message: "Customer banned successfully",
                Success: true,
        }, nil</span>
}

func (s *adminService) DeleteCustomer(ctx context.Context, customerID string) (*DeleteCustomerResponse, error) <span class="cov0" title="0">{
        // Convert customerID to ObjectID
        objectID, err := primitive.ObjectIDFromHex(customerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid customer ID format")
        }</span>

        // Get customer to verify it exists and is a customer
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get customer: %w", err)
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("customer not found")
        }</span>

        // Ensure user is a customer (not admin)
        <span class="cov0" title="0">if user.Role != domain.UserRoleCustomer </span><span class="cov0" title="0">{
                return nil, errors.New("can only delete customer accounts")
        }</span>

        // Delete the customer
        <span class="cov0" title="0">if err := s.userRepo.Delete(ctx, objectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete customer: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DeleteCustomerResponse{
                Message: "Customer deleted successfully",
                Success: true,
        }, nil</span>
}

func (s *adminService) InviteAdmin(ctx context.Context, adminID string, req InviteAdminRequest) (*InviteAdminResponse, error) <span class="cov0" title="0">{
        // Convert adminID to ObjectID
        adminObjectID, err := primitive.ObjectIDFromHex(adminID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid admin ID format")
        }</span>

        // Check if user already exists
        <span class="cov0" title="0">existingUser, err := s.userRepo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing user: %w", err)
        }</span>
        <span class="cov0" title="0">if existingUser != nil </span><span class="cov0" title="0">{
                return nil, errors.New("user with this email already exists")
        }</span>

        // Check if there's already a pending invite
        <span class="cov0" title="0">existingInvite, err := s.adminInviteRepo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing invite: %w", err)
        }</span>
        <span class="cov0" title="0">if existingInvite != nil </span><span class="cov0" title="0">{
                return nil, errors.New("admin invitation already pending for this email")
        }</span>

        // Create admin invite
        <span class="cov0" title="0">invite := &amp;domain.AdminInvite{
                InvitedBy:    adminObjectID,
                InviteeEmail: req.Email,
                ExpiresAt:    time.Now().Add(7 * 24 * time.Hour), // 7 days expiry
        }

        if err := s.adminInviteRepo.Create(ctx, invite); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create admin invite: %w", err)
        }</span>

        // Send invitation email (optional, depends on email service implementation)
        <span class="cov0" title="0">emailReq := SendEmailRequest{
                To:      []string{req.Email},
                Subject: "Admin Invitation - Bless2n Food System",
                Body: `
                        You have been invited to become an admin for the Bless2n Food System.
                        This invitation expires in 7 days.
                        
                        Please contact your administrator to complete the setup process.
                `,
        }

        if err := s.emailService.SendEmail(ctx, emailReq); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the invitation
                // The invite is created successfully, email failure is not critical
                fmt.Printf("Failed to send invitation email: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;InviteAdminResponse{
                Message: "Admin invitation sent successfully",
                Success: true,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package auth

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"

        "backend/internal/domain"
        "backend/internal/repository"
        "backend/internal/service"
)

type authService struct {
        userRepo     repository.UserRepository
        otpService   OTPService
        tokenService TokenService
}

func NewService(
        userRepo repository.UserRepository,
        otpService OTPService,
        tokenService TokenService,
) service.AuthService <span class="cov0" title="0">{
        return &amp;authService{
                userRepo:     userRepo,
                otpService:   otpService,
                tokenService: tokenService,
        }
}</span>

func (s *authService) RegisterCustomer(ctx context.Context, req service.RegisterCustomerRequest) (*service.RegisterCustomerResponse, error) <span class="cov7" title="4">{
        // Check if user already exists
        existingUser, err := s.userRepo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to check existing user", zap.Error(err))
                return nil, fmt.Errorf("failed to check existing user: %w", err)
        }</span>

        <span class="cov6" title="3">if existingUser != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user with email %s already exists", req.Email)
        }</span>

        // Create new customer user
        <span class="cov4" title="2">var user = &amp;domain.User{
                Email:      req.Email,
                Role:       domain.UserRoleCustomer,
                IsVerified: false,
                IsDisabled: false,
                CreatedAt:  time.Now(),
                UpdatedAt:  time.Now(),
        }

        if err := s.userRepo.Create(ctx, user); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to create user", zap.Error(err))
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov1" title="1">zap.L().Info("customer registered successfully",
                zap.String("user_id", user.ID.Hex()),
                zap.String("email", user.Email))

        return &amp;service.RegisterCustomerResponse{
                Message: "Registration successful.",
                UserID:  user.ID.Hex(),
        }, nil</span>
}

func (s *authService) RequestOTP(ctx context.Context, req service.RequestOTPRequest) (*service.RequestOTPResponse, error) <span class="cov9" title="6">{
        // Get user by email
        user, err := s.userRepo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to get user by email", zap.Error(err))
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov8" title="5">if user == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user not found")
        }</span>

        <span class="cov7" title="4">if user.IsDisabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("account is disabled: %s", *user.DisabledReason)
        }</span>

        // Generate and send new login OTP (works for both verified and unverified users)
        <span class="cov6" title="3">if err := s.otpService.GenerateAndSend(ctx, user.ID, req.Email, domain.TokenTypeLogin); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to generate and send login OTP", zap.Error(err))
                return nil, fmt.Errorf("failed to send login code: %w", err)
        }</span>

        <span class="cov4" title="2">zap.L().Info("login OTP sent successfully",
                zap.String("user_id", user.ID.Hex()),
                zap.String("email", user.Email),
                zap.Bool("user_verified", user.IsVerified))

        return &amp;service.RequestOTPResponse{
                Message: "Login code sent to your email.",
        }, nil</span>
}

func (s *authService) Login(ctx context.Context, req service.LoginRequest) (*service.LoginResponse, error) <span class="cov10" title="7">{
        // Get user by email
        user, err := s.userRepo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to get user by email", zap.Error(err))
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov10" title="7">if user == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid credentials")
        }</span>

        <span class="cov9" title="6">if user.IsDisabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("account is disabled: %s", *user.DisabledReason)
        }</span>

        // Verify OTP
        <span class="cov8" title="5">if err := s.otpService.Verify(ctx, user.ID, req.OTP, domain.TokenTypeLogin); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Mark user as verified if not already verified (first-time login verification)
        <span class="cov7" title="4">if !user.IsVerified </span><span class="cov4" title="2">{
                user.IsVerified = true
                user.UpdatedAt = time.Now()
                if err := s.userRepo.Update(ctx, user); err != nil </span><span class="cov1" title="1">{
                        zap.L().Error("failed to mark user as verified during login", zap.Error(err))
                        return nil, fmt.Errorf("failed to verify user: %w", err)
                }</span>
        }

        // Generate token pair
        <span class="cov6" title="3">tokenPair, err := s.tokenService.GenerateTokenPair(ctx, user, req.ClientID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="2">zap.L().Info("user logged in successfully",
                zap.String("user_id", user.ID.Hex()),
                zap.String("email", user.Email),
                zap.String("client_id", req.ClientID),
                zap.Bool("first_time_verification", !user.IsVerified))

        return &amp;service.LoginResponse{
                AccessToken:  tokenPair.AccessToken,
                RefreshToken: tokenPair.RefreshToken,
                TokenType:    tokenPair.TokenType,
                ExpiresIn:    tokenPair.ExpiresIn,
                User:         user,
        }, nil</span>
}

func (s *authService) RefreshToken(ctx context.Context, req service.RefreshTokenRequest) (*service.RefreshTokenResponse, error) <span class="cov4" title="2">{
        // Refresh token pair
        tokenPair, err := s.tokenService.RefreshTokenPair(ctx, req.RefreshToken, req.ClientID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;service.RefreshTokenResponse{
                AccessToken:  tokenPair.AccessToken,
                RefreshToken: tokenPair.RefreshToken,
                TokenType:    tokenPair.TokenType,
                ExpiresIn:    tokenPair.ExpiresIn,
        }, nil</span>
}

func (s *authService) Logout(ctx context.Context, req service.LogoutRequest) (*service.LogoutResponse, error) <span class="cov4" title="2">{
        // Revoke token family
        if err := s.tokenService.RevokeTokenFamily(ctx, req.RefreshToken, "user_logout"); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return &amp;service.LogoutResponse{Message: "Logged out successfully"}, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package auth

import (
        "context"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.uber.org/zap"

        "backend/internal/domain"
        "backend/internal/repository"
        "backend/internal/service"
        "backend/internal/utils"
)

type OTPService interface {
        GenerateAndSend(ctx context.Context, userID primitive.ObjectID, email string, tokenType domain.TokenType) error
        Verify(ctx context.Context, userID primitive.ObjectID, otp string, tokenType domain.TokenType) error
}

type otpService struct {
        otpRepo      repository.OTPTokenRepository
        emailService service.EmailService
}

func NewOTPService(
        otpRepo repository.OTPTokenRepository,
        emailService service.EmailService,
) OTPService <span class="cov0" title="0">{
        return &amp;otpService{
                otpRepo:      otpRepo,
                emailService: emailService,
        }
}</span>

func (s *otpService) GenerateAndSend(ctx context.Context, userID primitive.ObjectID, email string, tokenType domain.TokenType) error <span class="cov6" title="4">{
        // Generate OTP
        otp, err := utils.GenerateOTP()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate OTP: %w", err)
        }</span>

        // Hash OTP using Argon2id
        <span class="cov6" title="4">otpHash, err := utils.HashOTPArgon2(otp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash OTP: %w", err)
        }</span>

        // Create OTP token
        <span class="cov6" title="4">otpToken := &amp;domain.OTPToken{
                UserID:    userID,
                TokenHash: otpHash,
                Type:      tokenType,
                ExpiresAt: time.Now().Add(10 * time.Minute),
                CreatedAt: time.Now(),
        }

        // Save OTP token
        if err := s.otpRepo.Create(ctx, otpToken); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to save OTP token: %w", err)
        }</span>

        // Send OTP via email
        <span class="cov5" title="3">if err := s.emailService.SendOTP(ctx, email, otp); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to send OTP email: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

func (s *otpService) Verify(ctx context.Context, userID primitive.ObjectID, otp string, tokenType domain.TokenType) error <span class="cov10" title="10">{
        // Get latest OTP token for the user
        otpToken, err := s.otpRepo.GetLatestByUserAndType(ctx, userID, tokenType)
        if err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to get OTP token", zap.Error(err))
                return fmt.Errorf("failed to get OTP token: %w", err)
        }</span>
        <span class="cov9" title="9">if otpToken == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("no valid OTP found. Please request a new one")
        }</span>

        // Check expiry, usage, and attempts
        <span class="cov9" title="8">if time.Now().After(otpToken.ExpiresAt) </span><span class="cov1" title="1">{
                return fmt.Errorf("OTP has expired. Please request a new one")
        }</span>
        <span class="cov8" title="7">if otpToken.UsedAt != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("OTP has already been used. Please request a new one")
        }</span>
        <span class="cov8" title="6">if otpToken.Attempts &gt;= 3 </span><span class="cov1" title="1">{
                return fmt.Errorf("too many attempts. Please request a new OTP")
        }</span>

        // Verify OTP using Argon2id
        <span class="cov7" title="5">ok, verr := utils.VerifyOTPArgon2(otp, otpToken.TokenHash)
        if verr != nil || !ok </span><span class="cov7" title="5">{
                // Increment attempts on any verification failure
                if err := s.otpRepo.IncrementAttempts(ctx, otpToken.ID); err != nil </span><span class="cov0" title="0">{
                        zap.L().Error("failed to increment OTP attempts", zap.Error(err))
                }</span>
                <span class="cov7" title="5">return fmt.Errorf("invalid OTP code")</span>
        }

        // Mark OTP as used
        <span class="cov0" title="0">if err := s.otpRepo.MarkAsUsed(ctx, otpToken.ID); err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to mark OTP as used", zap.Error(err))
                return fmt.Errorf("failed to mark OTP as used: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package auth

import (
        "context"
        "fmt"
        "time"

        "go.uber.org/zap"

        "backend/internal/domain"
        "backend/internal/repository"
        "backend/internal/service"
        "backend/internal/utils"
)

const RefreshTokenDuration = 7 * 24 * time.Hour // 7 days

type TokenService interface {
        GenerateTokenPair(ctx context.Context, user *domain.User, clientID string) (*service.TokenPairResponse, error)
        RefreshTokenPair(ctx context.Context, refreshToken, clientID string) (*service.TokenPairResponse, error)
        RevokeTokenFamily(ctx context.Context, refreshToken, reason string) error
}

type tokenService struct {
        userRepo         repository.UserRepository
        refreshTokenRepo repository.RefreshTokenRepository
        jwtService       service.JWTService
}

func NewTokenService(
        userRepo repository.UserRepository,
        refreshTokenRepo repository.RefreshTokenRepository,
        jwtService service.JWTService,
) TokenService <span class="cov0" title="0">{
        return &amp;tokenService{
                userRepo:         userRepo,
                refreshTokenRepo: refreshTokenRepo,
                jwtService:       jwtService,
        }
}</span>

func (s *tokenService) GenerateTokenPair(ctx context.Context, user *domain.User, clientID string) (*service.TokenPairResponse, error) <span class="cov6" title="4">{
        // Revoke all existing refresh tokens for this user and client
        err := s.refreshTokenRepo.RevokeByClientID(ctx, user.ID, clientID, "new_login")
        if err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to revoke existing refresh tokens", zap.Error(err))
                return nil, fmt.Errorf("failed to revoke existing refresh tokens: %w", err)
        }</span>

        // Generate token pair
        <span class="cov5" title="3">tokenPair, err := s.jwtService.GenerateTokenPair(user, clientID)
        if err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to generate token pair", zap.Error(err))
                return nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        // Generate family ID for refresh token rotation
        <span class="cov3" title="2">familyID, err := utils.GenerateFamilyID()
        if err != nil </span><span class="cov0" title="0">{
                zap.L().Error("failed to generate family ID", zap.Error(err))
                return nil, fmt.Errorf("failed to generate family ID: %w", err)
        }</span>

        // Store refresh token
        <span class="cov3" title="2">refreshToken := &amp;domain.RefreshToken{
                UserID:    user.ID,
                ClientID:  clientID,
                FamilyID:  familyID,
                ExpiresAt: time.Now().Add(RefreshTokenDuration),
        }

        if err := s.refreshTokenRepo.CreateWithPlainToken(ctx, refreshToken, tokenPair.RefreshToken); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to store refresh token", zap.Error(err))
                return nil, fmt.Errorf("failed to store refresh token: %w", err)
        }</span>

        <span class="cov1" title="1">zap.L().Info("token pair generated successfully",
                zap.String("user_id", user.ID.Hex()),
                zap.String("client_id", clientID))

        return tokenPair, nil</span>
}

func (s *tokenService) RefreshTokenPair(ctx context.Context, refreshToken, clientID string) (*service.TokenPairResponse, error) <span class="cov10" title="10">{
        // Find the refresh token
        storedToken, err := s.refreshTokenRepo.GetValidTokenForUser(ctx, refreshToken)
        if err != nil </span><span class="cov3" title="2">{
                if err == domain.ErrRefreshTokenNotFound </span><span class="cov1" title="1">{
                        zap.L().Warn("refresh token not found or invalid")
                        return nil, fmt.Errorf("invalid refresh token")
                }</span>
                <span class="cov1" title="1">zap.L().Error("failed to get refresh token", zap.Error(err))
                return nil, fmt.Errorf("failed to validate refresh token: %w", err)</span>
        }

        // Check client ID match
        <span class="cov9" title="8">if storedToken.ClientID != clientID </span><span class="cov1" title="1">{
                zap.L().Warn("client ID mismatch for refresh token",
                        zap.String("stored_client_id", storedToken.ClientID),
                        zap.String("request_client_id", clientID))
                return nil, fmt.Errorf("invalid client")
        }</span>

        <span class="cov8" title="7">return s.rotateRefreshToken(ctx, storedToken, clientID)</span>
}

func (s *tokenService) rotateRefreshToken(ctx context.Context, storedToken *domain.RefreshToken, clientID string) (*service.TokenPairResponse, error) <span class="cov8" title="7">{
        // Get user
        user, err := s.userRepo.GetByID(ctx, storedToken.UserID)
        if err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to get user", zap.Error(err))
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov8" title="6">if user == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user not found")
        }</span>

        <span class="cov7" title="5">if user.IsDisabled </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("account is disabled")
        }</span>

        // Generate new token pair
        <span class="cov6" title="4">tokenPair, err := s.jwtService.GenerateTokenPair(user, clientID)
        if err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to generate token pair", zap.Error(err))
                return nil, fmt.Errorf("failed to generate tokens: %w", err)
        }</span>

        // Revoke the old refresh token (refresh token rotation)
        <span class="cov5" title="3">if err := s.refreshTokenRepo.RevokeByID(ctx, storedToken.ID, "token_rotation"); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to revoke old refresh token", zap.Error(err))
                return nil, fmt.Errorf("failed to rotate token: %w", err)
        }</span>

        // Create new refresh token with same family ID
        <span class="cov3" title="2">newRefreshToken := &amp;domain.RefreshToken{
                UserID:    storedToken.UserID,
                ClientID:  clientID,
                FamilyID:  storedToken.FamilyID, // Keep same family ID for rotation
                ExpiresAt: time.Now().Add(RefreshTokenDuration),
        }

        if err := s.refreshTokenRepo.CreateWithPlainToken(ctx, newRefreshToken, tokenPair.RefreshToken); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to store new refresh token", zap.Error(err))
                return nil, fmt.Errorf("failed to store refresh token: %w", err)
        }</span>

        // Update last used timestamp of the stored token for tracking
        <span class="cov1" title="1">if err := s.refreshTokenRepo.UpdateLastUsed(ctx, storedToken.ID); err != nil </span><span class="cov0" title="0">{
                zap.L().Warn("failed to update last used timestamp", zap.Error(err))
        }</span>

        <span class="cov1" title="1">zap.L().Info("refresh token rotated successfully",
                zap.String("user_id", storedToken.UserID.Hex()),
                zap.String("client_id", clientID))

        return &amp;service.TokenPairResponse{
                AccessToken:  tokenPair.AccessToken,
                RefreshToken: tokenPair.RefreshToken,
                TokenType:    tokenPair.TokenType,
                ExpiresIn:    tokenPair.ExpiresIn,
        }, nil</span>
}

func (s *tokenService) RevokeTokenFamily(ctx context.Context, refreshToken, reason string) error <span class="cov6" title="4">{
        // Find the refresh token
        storedToken, err := s.refreshTokenRepo.GetValidTokenForUser(ctx, refreshToken)
        if err != nil </span><span class="cov3" title="2">{
                if err == domain.ErrRefreshTokenNotFound </span><span class="cov1" title="1">{
                        // Token not found, but that's okay for logout
                        return nil
                }</span>
                <span class="cov1" title="1">zap.L().Error("failed to get refresh token", zap.Error(err))
                return fmt.Errorf("failed to validate refresh token: %w", err)</span>
        }

        // Revoke all tokens in the same family
        <span class="cov3" title="2">if err := s.refreshTokenRepo.RevokeByFamilyID(ctx, storedToken.FamilyID, reason); err != nil </span><span class="cov1" title="1">{
                zap.L().Error("failed to revoke token family", zap.Error(err))
                return fmt.Errorf("failed to revoke tokens: %w", err)
        }</span>

        <span class="cov1" title="1">zap.L().Info("token family revoked successfully",
                zap.String("user_id", storedToken.UserID.Hex()),
                zap.String("family_id", storedToken.FamilyID),
                zap.String("reason", reason))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"

        "backend/internal/domain"
        "backend/internal/repository"

        "go.mongodb.org/mongo-driver/bson/primitive"
)

type CategoryService interface {
        CreateCategory(ctx context.Context, req CreateCategoryRequest) (*CreateCategoryResponse, error)
        GetCategory(ctx context.Context, categoryID string) (*GetCategoryResponse, error)
        UpdateCategory(ctx context.Context, categoryID string, req UpdateCategoryRequest) (*UpdateCategoryResponse, error)
        DeleteCategory(ctx context.Context, categoryID string) (*DeleteCategoryResponse, error)
        ListCategories(ctx context.Context, activeOnly bool, limit, offset int) (*ListCategoriesResponse, error)
        SetCategoryActive(ctx context.Context, categoryID string, isActive bool) (*SetCategoryActiveResponse, error)
}

type CreateCategoryRequest struct {
        Name string `json:"name" validate:"required"`
}

type CreateCategoryResponse struct {
        Category CategoryDTO `json:"category"`
        Message  string      `json:"message"`
        Success  bool        `json:"success"`
}

type GetCategoryResponse struct {
        Category CategoryDTO `json:"category"`
}

type UpdateCategoryRequest struct {
        Name string `json:"name" validate:"required"`
}

type UpdateCategoryResponse struct {
        Category CategoryDTO `json:"category"`
        Message  string      `json:"message"`
        Success  bool        `json:"success"`
}

type DeleteCategoryResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type ListCategoriesResponse struct {
        Categories []CategoryDTO `json:"categories"`
        Total      int           `json:"total"`
}

type SetCategoryActiveResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type CategoryDTO struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        IsActive  bool   `json:"is_active"`
        CreatedAt string `json:"created_at"`
        UpdatedAt string `json:"updated_at"`
}

type categoryService struct {
        categoryRepo repository.CategoryRepository
}

func NewCategoryService(categoryRepo repository.CategoryRepository) CategoryService <span class="cov0" title="0">{
        return &amp;categoryService{
                categoryRepo: categoryRepo,
        }
}</span>

func (s *categoryService) CreateCategory(ctx context.Context, req CreateCategoryRequest) (*CreateCategoryResponse, error) <span class="cov0" title="0">{
        existingCategory, err := s.categoryRepo.GetByName(ctx, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check existing category: %w", err)
        }</span>
        <span class="cov0" title="0">if existingCategory != nil </span><span class="cov0" title="0">{
                return nil, errors.New("category with this name already exists")
        }</span>

        <span class="cov0" title="0">category := &amp;domain.Category{
                Name: req.Name,
        }

        if err := s.categoryRepo.Create(ctx, category); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create category: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;CreateCategoryResponse{
                Category: s.toCategoryDTO(category),
                Message:  "Category created successfully",
                Success:  true,
        }, nil</span>
}

func (s *categoryService) GetCategory(ctx context.Context, categoryID string) (*GetCategoryResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid category ID format")
        }</span>

        <span class="cov0" title="0">category, err := s.categoryRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get category: %w", err)
        }</span>
        <span class="cov0" title="0">if category == nil </span><span class="cov0" title="0">{
                return nil, errors.New("category not found")
        }</span>

        <span class="cov0" title="0">return &amp;GetCategoryResponse{
                Category: s.toCategoryDTO(category),
        }, nil</span>
}

func (s *categoryService) UpdateCategory(ctx context.Context, categoryID string, req UpdateCategoryRequest) (*UpdateCategoryResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid category ID format")
        }</span>

        <span class="cov0" title="0">category, err := s.categoryRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get category: %w", err)
        }</span>
        <span class="cov0" title="0">if category == nil </span><span class="cov0" title="0">{
                return nil, errors.New("category not found")
        }</span>

        <span class="cov0" title="0">if category.Name != req.Name </span><span class="cov0" title="0">{
                existingCategory, err := s.categoryRepo.GetByName(ctx, req.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check existing category: %w", err)
                }</span>
                <span class="cov0" title="0">if existingCategory != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("category with this name already exists")
                }</span>
        }

        <span class="cov0" title="0">category.Name = req.Name

        if err := s.categoryRepo.Update(ctx, category); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update category: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UpdateCategoryResponse{
                Category: s.toCategoryDTO(category),
                Message:  "Category updated successfully",
                Success:  true,
        }, nil</span>
}

func (s *categoryService) DeleteCategory(ctx context.Context, categoryID string) (*DeleteCategoryResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid category ID format")
        }</span>

        <span class="cov0" title="0">category, err := s.categoryRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get category: %w", err)
        }</span>
        <span class="cov0" title="0">if category == nil </span><span class="cov0" title="0">{
                return nil, errors.New("category not found")
        }</span>

        <span class="cov0" title="0">if err := s.categoryRepo.Delete(ctx, objectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete category: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DeleteCategoryResponse{
                Message: "Category deleted successfully",
                Success: true,
        }, nil</span>
}

func (s *categoryService) ListCategories(ctx context.Context, activeOnly bool, limit, offset int) (*ListCategoriesResponse, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">categories, err := s.categoryRepo.List(ctx, activeOnly, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list categories: %w", err)
        }</span>

        <span class="cov0" title="0">categoryDTOs := make([]CategoryDTO, len(categories))
        for i, category := range categories </span><span class="cov0" title="0">{
                categoryDTOs[i] = s.toCategoryDTO(category)
        }</span>

        <span class="cov0" title="0">return &amp;ListCategoriesResponse{
                Categories: categoryDTOs,
                Total:      len(categoryDTOs),
        }, nil</span>
}

func (s *categoryService) SetCategoryActive(ctx context.Context, categoryID string, isActive bool) (*SetCategoryActiveResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid category ID format")
        }</span>

        <span class="cov0" title="0">category, err := s.categoryRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get category: %w", err)
        }</span>
        <span class="cov0" title="0">if category == nil </span><span class="cov0" title="0">{
                return nil, errors.New("category not found")
        }</span>

        <span class="cov0" title="0">if err := s.categoryRepo.SetActive(ctx, objectID, isActive); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update category status: %w", err)
        }</span>

        <span class="cov0" title="0">var action string
        if isActive </span><span class="cov0" title="0">{
                action = "activated"
        }</span> else<span class="cov0" title="0"> {
                action = "deactivated"
        }</span>

        <span class="cov0" title="0">return &amp;SetCategoryActiveResponse{
                Message: fmt.Sprintf("Category %s successfully", action),
                Success: true,
        }, nil</span>
}

func (s *categoryService) toCategoryDTO(category *domain.Category) CategoryDTO <span class="cov0" title="0">{
        return CategoryDTO{
                ID:        category.ID.Hex(),
                Name:      category.Name,
                IsActive:  category.IsActive,
                CreatedAt: category.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt: category.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }
}</pre>
		
		<pre class="file" id="file42" style="display: none">package service

import (
        "context"
        "fmt"
        "net/smtp"

        "backend/internal/config"

        "go.uber.org/zap"
)

type EmailService interface {
        SendOTP(ctx context.Context, email, otp string) error
        SendEmail(ctx context.Context, req SendEmailRequest) error
}

type SendEmailRequest struct {
        To      []string `json:"to" validate:"required"`
        Subject string   `json:"subject" validate:"required"`
        Body    string   `json:"body" validate:"required"`
}

type emailService struct {
        config config.SmtpConfig
}

func NewEmailService(cfg config.Config) EmailService <span class="cov6" title="4">{
        return &amp;emailService{
                config: cfg.Smtp,
        }
}</span>

func (s *emailService) SendOTP(ctx context.Context, email, otp string) error <span class="cov8" title="6">{
        subject := "Dein BlessThun Code"
        body := fmt.Sprintf(`
Hey,

Dein Anmeldecode fr BlessThun ist: %s

Dieser Code luft in 10 Minuten ab.

Wenn du diesen Code nicht angefordert hast, ignoriere bitte diese E-Mail.

- Dein BlessThun Team
`, otp)

        return s.sendEmail(email, subject, body)
}</span>

func (s *emailService) SendEmail(ctx context.Context, req SendEmailRequest) error <span class="cov8" title="6">{
        if len(req.To) == 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("no recipients specified")
        }</span>

        // Send email to each recipient
        <span class="cov6" title="4">for _, recipient := range req.To </span><span class="cov6" title="4">{
                if err := s.sendEmail(recipient, req.Subject, req.Body); err != nil </span><span class="cov6" title="4">{
                        return fmt.Errorf("failed to send email to %s: %w", recipient, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *emailService) sendEmail(to, subject, body string) error <span class="cov10" title="10">{
        from := s.config.From
        password := s.config.Password

        // Set up authentication information.
        auth := smtp.PlainAuth("", s.config.Username, password, s.config.Host)

        // Compose the message
        msg := []byte(fmt.Sprintf("To: %s\r\nSubject: %s\r\n\r\n%s\r\n", to, subject, body))

        // Send the email
        addr := fmt.Sprintf("%s:%s", s.config.Host, s.config.Port)
        err := smtp.SendMail(addr, auth, from, []string{to}, msg)
        if err != nil </span><span class="cov10" title="10">{
                zap.L().Error("failed to send email",
                        zap.String("to", to),
                        zap.String("subject", subject),
                        zap.Error(err))
                return fmt.Errorf("failed to send email: %w", err)
        }</span>

        <span class="cov0" title="0">zap.L().Info("email sent successfully",
                zap.String("to", to),
                zap.String("subject", subject))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package service

import (
        "crypto/ed25519"
        "crypto/rand"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "os"
        "time"

        "github.com/golang-jwt/jwt/v5"

        "backend/internal/domain"
)

const (
        AccessTokenDuration  = 10 * time.Minute
        RefreshTokenDuration = 7 * 24 * time.Hour
        RefreshTokenLength   = 32

        defaultAudience = "blessthun-food-api"
)

type TokenClaims struct {
        Role domain.UserRole `json:"role"`
        jwt.RegisteredClaims
}

type JWTService interface {
        GenerateAccessToken(user *domain.User) (string, error)
        GenerateRefreshToken() (string, error)
        ValidateAccessToken(tokenString string) (*TokenClaims, error)
        GenerateTokenPair(user *domain.User, clientID string) (*TokenPairResponse, error)
}

type TokenPairResponse struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
        TokenType    string `json:"token_type"`
        ExpiresIn    int64  `json:"expires_in"`
}

type jwtService struct {
        privateKey ed25519.PrivateKey
        publicKey  ed25519.PublicKey
        issuer     string
        audience   string
}

func NewJWTService(jwtPrivPemPath string, jwtPubPemPath string, issuer string) JWTService <span class="cov0" title="0">{
        priv, pub, err := loadEd25519Keys(jwtPrivPemPath, jwtPubPemPath)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to load Ed25519 keys: %v", err))</span>
        }
        <span class="cov0" title="0">return &amp;jwtService{
                privateKey: priv,
                publicKey:  pub,
                issuer:     issuer,
                audience:   defaultAudience,
        }</span>
}

func loadEd25519Keys(privPath, pubPath string) (ed25519.PrivateKey, ed25519.PublicKey, error) <span class="cov0" title="0">{
        privPEM, err := os.ReadFile(privPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("read private key: %w", err)
        }</span>
        <span class="cov0" title="0">block, _ := pem.Decode(privPEM)
        if block == nil || block.Type != "PRIVATE KEY" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("invalid private key PEM: got %v", block)
        }</span>
        <span class="cov0" title="0">anyKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("parse PKCS#8 private key: %w", err)
        }</span>
        <span class="cov0" title="0">priv, ok := anyKey.(ed25519.PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("not an Ed25519 private key")
        }</span>
        <span class="cov0" title="0">if l := len(priv); l != ed25519.PrivateKeySize </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("bad ed25519 key length: %d", l)
        }</span>

        <span class="cov0" title="0">pubPEM, err := os.ReadFile(pubPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("read public key: %w", err)
        }</span>
        <span class="cov0" title="0">pb, _ := pem.Decode(pubPEM)
        if pb == nil || pb.Type != "PUBLIC KEY" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("invalid public key PEM: got %v", pb)
        }</span>
        <span class="cov0" title="0">anyPub, err := x509.ParsePKIXPublicKey(pb.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("parse PKIX public key: %w", err)
        }</span>
        <span class="cov0" title="0">pub, ok2 := anyPub.(ed25519.PublicKey)
        if !ok2 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("not an Ed25519 public key")
        }</span>
        <span class="cov0" title="0">if l := len(pub); l != ed25519.PublicKeySize </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("bad ed25519 key length: %d", l)
        }</span>

        <span class="cov0" title="0">return priv, pub, nil</span>
}

func (j *jwtService) GenerateAccessToken(user *domain.User) (string, error) <span class="cov0" title="0">{
        now := time.Now().UTC()

        jti, err := generateJTI()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate JTI: %w", err)
        }</span>

        <span class="cov0" title="0">claims := TokenClaims{
                Role: user.Role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ID:        jti,
                        Subject:   user.ID.Hex(),
                        IssuedAt:  jwt.NewNumericDate(now),
                        ExpiresAt: jwt.NewNumericDate(now.Add(AccessTokenDuration)),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    j.issuer,
                        Audience:  []string{j.audience},
                },
        }

        tok := jwt.NewWithClaims(jwt.SigningMethodEdDSA, claims)
        return tok.SignedString(j.privateKey)</span>
}

func (j *jwtService) GenerateRefreshToken() (string, error) <span class="cov0" title="0">{
        // 32 chars from a 64-symbol alphabet  192 bits of entropy
        bytes := make([]byte, RefreshTokenLength)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>
        <span class="cov0" title="0">const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        out := make([]byte, RefreshTokenLength)
        for i, b := range bytes </span><span class="cov0" title="0">{
                out[i] = chars[int(b)%len(chars)]
        }</span>
        <span class="cov0" title="0">return string(out), nil</span>
}

func (j *jwtService) ValidateAccessToken(tokenString string) (*TokenClaims, error) <span class="cov0" title="0">{
        parser := jwt.NewParser(
                jwt.WithValidMethods([]string{jwt.SigningMethodEdDSA.Alg()}),
                jwt.WithIssuer(j.issuer),
                jwt.WithAudience(j.audience),
        )

        var claims TokenClaims
        token, err := parser.ParseWithClaims(tokenString, &amp;claims, func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if t.Method != jwt.SigningMethodEdDSA </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing alg: %v", t.Header["alg"])
                }</span>
                <span class="cov0" title="0">return j.publicKey, nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse/validate token: %w", err)
        }</span>
        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>
        <span class="cov0" title="0">return &amp;claims, nil</span>
}

func (j *jwtService) GenerateTokenPair(user *domain.User, clientID string) (*TokenPairResponse, error) <span class="cov0" title="0">{
        accessToken, err := j.GenerateAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate access token: %w", err)
        }</span>

        <span class="cov0" title="0">refreshToken, err := j.GenerateRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate refresh token: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;TokenPairResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                TokenType:    "Bearer",
                ExpiresIn:    int64(AccessTokenDuration.Seconds()),
        }, nil</span>
}

func generateJTI() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 16)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("at_%x", b), nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "time"

        "backend/internal/domain"
        "backend/internal/repository"

        "go.mongodb.org/mongo-driver/bson/primitive"
)

type OrderService interface {
        CreateOrder(ctx context.Context, req CreateOrderRequest) (*CreateOrderResponse, error)
        GetOrder(ctx context.Context, orderID string) (*GetOrderResponse, error)
        UpdateOrder(ctx context.Context, orderID string, req UpdateOrderRequest) (*UpdateOrderResponse, error)
        DeleteOrder(ctx context.Context, orderID string) (*DeleteOrderResponse, error)
        ListOrders(ctx context.Context, req ListOrdersRequest) (*ListOrdersResponse, error)
        UpdateOrderStatus(ctx context.Context, orderID string, status domain.OrderStatus) (*UpdateOrderStatusResponse, error)
        GetOrdersByCustomer(ctx context.Context, customerID string, limit, offset int) (*ListOrdersResponse, error)
        GetOrdersByEmail(ctx context.Context, email string, limit, offset int) (*ListOrdersResponse, error)
        GetOrderForRedemption(ctx context.Context, orderID, stationID string) (*OrderRedemptionResponse, error)
        RedeemOrderItems(ctx context.Context, req RedeemOrderItemsRequest) (*RedeemOrderItemsResponse, error)
}

type CreateOrderRequest struct {
        CustomerID   *string                `json:"customer_id,omitempty"`
        ContactEmail *string                `json:"contact_email,omitempty"`
        Items        []CreateOrderItemRequest `json:"items" validate:"required,dive"`
}

type CreateOrderItemRequest struct {
        ProductID string `json:"product_id" validate:"required"`
        Quantity  int    `json:"quantity" validate:"required,gt=0"`
}

type CreateOrderResponse struct {
        Order   OrderDTO `json:"order"`
        Message string   `json:"message"`
        Success bool     `json:"success"`
}

type GetOrderResponse struct {
        Order OrderDTO          `json:"order"`
        Items []OrderItemDTO    `json:"items"`
}

type UpdateOrderRequest struct {
        ContactEmail *string `json:"contact_email,omitempty"`
        Items        *[]CreateOrderItemRequest `json:"items,omitempty" validate:"omitempty,dive"`
}

type UpdateOrderResponse struct {
        Order   OrderDTO `json:"order"`
        Message string   `json:"message"`
        Success bool     `json:"success"`
}

type DeleteOrderResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type ListOrdersRequest struct {
        Status   *domain.OrderStatus `json:"status,omitempty"`
        Limit    int                 `json:"limit,omitempty"`
        Offset   int                 `json:"offset,omitempty"`
}

type ListOrdersResponse struct {
        Orders []OrderDTO `json:"orders"`
        Total  int        `json:"total"`
}

type UpdateOrderStatusResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type OrderRedemptionResponse struct {
        Order             OrderDTO                  `json:"order"`
        RedeemableItems   []RedeemableOrderItemDTO  `json:"redeemable_items"`
        AlreadyRedeemed   []OrderItemDTO            `json:"already_redeemed"`
        Message           string                    `json:"message"`
}

type RedeemableOrderItemDTO struct {
        ID                string  `json:"id"`
        ProductID         string  `json:"product_id"`
        ProductName       string  `json:"product_name"`
        Type              string  `json:"type"`
        Quantity          int     `json:"quantity"`
        PricePerUnit      float64 `json:"price_per_unit"`
        IsBundle          bool    `json:"is_bundle"`
        ComponentItems    []OrderItemDTO `json:"component_items,omitempty"`
}

type RedeemOrderItemsRequest struct {
        OrderID   string `json:"order_id" validate:"required"`
        StationID string `json:"station_id" validate:"required"`
        DeviceID  string `json:"device_id" validate:"required"`
}

type RedeemOrderItemsResponse struct {
        RedeemedItems []OrderItemDTO `json:"redeemed_items"`
        Message       string         `json:"message"`
        Success       bool           `json:"success"`
}

type OrderDTO struct {
        ID           string  `json:"id"`
        CustomerID   *string `json:"customer_id,omitempty"`
        ContactEmail *string `json:"contact_email,omitempty"`
        Total        float64 `json:"total"`
        Status       string  `json:"status"`
        CreatedAt    string  `json:"created_at"`
        UpdatedAt    string  `json:"updated_at"`
}

type OrderItemDTO struct {
        ID                string  `json:"id"`
        OrderID           string  `json:"order_id"`
        ProductID         string  `json:"product_id"`
        ParentItemID      *string `json:"parent_item_id,omitempty"`
        Type              string  `json:"type"`
        Title             string  `json:"title"`
        Quantity          int     `json:"quantity"`
        PricePerUnit      float64 `json:"price_per_unit"`
        IsRedeemed        bool    `json:"is_redeemed"`
        RedeemedAt        *string `json:"redeemed_at,omitempty"`
        RedeemedStationID *string `json:"redeemed_station_id,omitempty"`
        RedeemedDeviceID  *string `json:"redeemed_device_id,omitempty"`
}

type orderService struct {
        orderRepo           repository.OrderRepository
        orderItemRepo       repository.OrderItemRepository
        productRepo         repository.ProductRepository
        bundleComponentRepo repository.ProductBundleComponentRepository
        inventoryLedgerRepo repository.InventoryLedgerRepository
        userRepo            repository.UserRepository
        stationProductRepo  repository.StationProductRepository
        stationRepo         repository.StationRepository
        deviceRepo          repository.DeviceRepository
}

func NewOrderService(
        orderRepo repository.OrderRepository,
        orderItemRepo repository.OrderItemRepository,
        productRepo repository.ProductRepository,
        bundleComponentRepo repository.ProductBundleComponentRepository,
        inventoryLedgerRepo repository.InventoryLedgerRepository,
        userRepo repository.UserRepository,
        stationProductRepo repository.StationProductRepository,
        stationRepo repository.StationRepository,
        deviceRepo repository.DeviceRepository,
) OrderService <span class="cov0" title="0">{
        return &amp;orderService{
                orderRepo:           orderRepo,
                orderItemRepo:       orderItemRepo,
                productRepo:         productRepo,
                bundleComponentRepo: bundleComponentRepo,
                inventoryLedgerRepo: inventoryLedgerRepo,
                userRepo:            userRepo,
                stationProductRepo:  stationProductRepo,
                stationRepo:         stationRepo,
                deviceRepo:          deviceRepo,
        }
}</span>

func (s *orderService) CreateOrder(ctx context.Context, req CreateOrderRequest) (*CreateOrderResponse, error) <span class="cov0" title="0">{
        if req.CustomerID == nil &amp;&amp; req.ContactEmail == nil </span><span class="cov0" title="0">{
                return nil, errors.New("either customer_id or contact_email must be provided")
        }</span>

        <span class="cov0" title="0">if len(req.Items) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("order must contain at least one item")
        }</span>

        <span class="cov0" title="0">var customerID *primitive.ObjectID
        if req.CustomerID != nil </span><span class="cov0" title="0">{
                id, err := primitive.ObjectIDFromHex(*req.CustomerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid customer ID format")
                }</span>
                
                // Verify customer exists
                <span class="cov0" title="0">customer, err := s.userRepo.GetByID(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to verify customer: %w", err)
                }</span>
                <span class="cov0" title="0">if customer == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("customer not found")
                }</span>
                <span class="cov0" title="0">customerID = &amp;id</span>
        }

        // Calculate total and validate items
        <span class="cov0" title="0">var orderItems []*domain.OrderItem
        var total float64

        for _, itemReq := range req.Items </span><span class="cov0" title="0">{
                productID, err := primitive.ObjectIDFromHex(itemReq.ProductID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid product ID format: %s", itemReq.ProductID)
                }</span>

                <span class="cov0" title="0">product, err := s.productRepo.GetByID(ctx, productID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get product: %w", err)
                }</span>
                <span class="cov0" title="0">if product == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("product not found: %s", itemReq.ProductID)
                }</span>

                <span class="cov0" title="0">if !product.IsActive </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("product is not active: %s", product.Name)
                }</span>

                // Check inventory availability
                <span class="cov0" title="0">currentStock, err := s.inventoryLedgerRepo.GetCurrentStock(ctx, productID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check inventory for product %s: %w", product.Name, err)
                }</span>

                <span class="cov0" title="0">if product.Type == domain.ProductTypeSimple </span><span class="cov0" title="0">{
                        if currentStock &lt; itemReq.Quantity </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("insufficient stock for product %s: available %d, requested %d", product.Name, currentStock, itemReq.Quantity)
                        }</span>

                        // Create simple product order item
                        <span class="cov0" title="0">orderItem := &amp;domain.OrderItem{
                                ProductID:    productID,
                                Type:         domain.OrderItemTypeSimple,
                                Title:        product.Name,
                                Quantity:     itemReq.Quantity,
                                PricePerUnit: product.Price,
                        }
                        orderItems = append(orderItems, orderItem)
                        total += product.Price * float64(itemReq.Quantity)</span>

                } else<span class="cov0" title="0"> if product.Type == domain.ProductTypeBundle </span><span class="cov0" title="0">{
                        // Handle bundle products
                        bundleComponents, err := s.bundleComponentRepo.GetByBundleID(ctx, productID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get bundle components: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(bundleComponents) == 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("bundle has no components: %s", product.Name)
                        }</span>

                        // Check stock for all components
                        <span class="cov0" title="0">for _, component := range bundleComponents </span><span class="cov0" title="0">{
                                componentStock, err := s.inventoryLedgerRepo.GetCurrentStock(ctx, component.ComponentProductID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to check component stock: %w", err)
                                }</span>

                                <span class="cov0" title="0">requiredComponentQty := component.Quantity * itemReq.Quantity
                                if componentStock &lt; requiredComponentQty </span><span class="cov0" title="0">{
                                        componentProduct, _ := s.productRepo.GetByID(ctx, component.ComponentProductID)
                                        componentName := "Unknown"
                                        if componentProduct != nil </span><span class="cov0" title="0">{
                                                componentName = componentProduct.Name
                                        }</span>
                                        <span class="cov0" title="0">return nil, fmt.Errorf("insufficient stock for bundle component %s: available %d, required %d", componentName, componentStock, requiredComponentQty)</span>
                                }
                        }

                        // Create bundle order item
                        <span class="cov0" title="0">bundleItem := &amp;domain.OrderItem{
                                ProductID:    productID,
                                Type:         domain.OrderItemTypeBundle,
                                Title:        product.Name,
                                Quantity:     itemReq.Quantity,
                                PricePerUnit: product.Price,
                        }
                        orderItems = append(orderItems, bundleItem)
                        total += product.Price * float64(itemReq.Quantity)</span>
                }
        }

        // Create the order
        <span class="cov0" title="0">order := &amp;domain.Order{
                CustomerID:   customerID,
                ContactEmail: req.ContactEmail,
                Total:        total,
                Status:       domain.OrderStatusPending,
        }

        if err := s.orderRepo.Create(ctx, order); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create order: %w", err)
        }</span>

        // Create order items and update inventory
        <span class="cov0" title="0">for _, orderItem := range orderItems </span><span class="cov0" title="0">{
                orderItem.OrderID = order.ID
                if err := s.orderItemRepo.Create(ctx, orderItem); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create order item: %w", err)
                }</span>

                // Handle inventory updates
                <span class="cov0" title="0">if orderItem.Type == domain.OrderItemTypeSimple </span><span class="cov0" title="0">{
                        // Deduct inventory for simple products
                        inventoryEntry := &amp;domain.InventoryLedger{
                                ProductID: orderItem.ProductID,
                                Delta:     -orderItem.Quantity,
                                Reason:    domain.InventoryReasonSale,
                        }
                        if err := s.inventoryLedgerRepo.Create(ctx, inventoryEntry); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to update inventory: %w", err)
                        }</span>

                } else<span class="cov0" title="0"> if orderItem.Type == domain.OrderItemTypeBundle </span><span class="cov0" title="0">{
                        // Create component items and deduct inventory
                        bundleComponents, err := s.bundleComponentRepo.GetByBundleID(ctx, orderItem.ProductID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to get bundle components: %w", err)
                        }</span>

                        <span class="cov0" title="0">for _, component := range bundleComponents </span><span class="cov0" title="0">{
                                componentProduct, err := s.productRepo.GetByID(ctx, component.ComponentProductID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to get component product: %w", err)
                                }</span>

                                <span class="cov0" title="0">componentQuantity := component.Quantity * orderItem.Quantity

                                // Create component order item
                                componentOrderItem := &amp;domain.OrderItem{
                                        OrderID:      order.ID,
                                        ProductID:    component.ComponentProductID,
                                        ParentItemID: &amp;orderItem.ID,
                                        Type:         domain.OrderItemTypeComponent,
                                        Title:        componentProduct.Name,
                                        Quantity:     componentQuantity,
                                        PricePerUnit: 0, // Component items don't have individual prices
                                }

                                if err := s.orderItemRepo.Create(ctx, componentOrderItem); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to create component order item: %w", err)
                                }</span>

                                // Deduct component inventory
                                <span class="cov0" title="0">inventoryEntry := &amp;domain.InventoryLedger{
                                        ProductID: component.ComponentProductID,
                                        Delta:     -componentQuantity,
                                        Reason:    domain.InventoryReasonSale,
                                }
                                if err := s.inventoryLedgerRepo.Create(ctx, inventoryEntry); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to update component inventory: %w", err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return &amp;CreateOrderResponse{
                Order:   s.toOrderDTO(order),
                Message: "Order created successfully",
                Success: true,
        }, nil</span>
}

func (s *orderService) GetOrder(ctx context.Context, orderID string) (*GetOrderResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid order ID format")
        }</span>

        <span class="cov0" title="0">order, err := s.orderRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order: %w", err)
        }</span>
        <span class="cov0" title="0">if order == nil </span><span class="cov0" title="0">{
                return nil, errors.New("order not found")
        }</span>

        <span class="cov0" title="0">items, err := s.orderItemRepo.GetByOrderID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order items: %w", err)
        }</span>

        <span class="cov0" title="0">itemDTOs := make([]OrderItemDTO, len(items))
        for i, item := range items </span><span class="cov0" title="0">{
                itemDTOs[i] = s.toOrderItemDTO(item)
        }</span>

        <span class="cov0" title="0">return &amp;GetOrderResponse{
                Order: s.toOrderDTO(order),
                Items: itemDTOs,
        }, nil</span>
}

func (s *orderService) UpdateOrder(ctx context.Context, orderID string, req UpdateOrderRequest) (*UpdateOrderResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid order ID format")
        }</span>

        <span class="cov0" title="0">order, err := s.orderRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order: %w", err)
        }</span>
        <span class="cov0" title="0">if order == nil </span><span class="cov0" title="0">{
                return nil, errors.New("order not found")
        }</span>

        <span class="cov0" title="0">if order.Status != domain.OrderStatusPending </span><span class="cov0" title="0">{
                return nil, errors.New("can only update pending orders")
        }</span>

        <span class="cov0" title="0">if req.ContactEmail != nil </span><span class="cov0" title="0">{
                order.ContactEmail = req.ContactEmail
        }</span>

        // Handle items update if provided
        <span class="cov0" title="0">if req.Items != nil </span><span class="cov0" title="0">{
                // This would require reversing inventory changes and creating new ones
                // For now, we'll just update the contact email
                // Full item update implementation would be more complex
                return nil, errors.New("updating order items is not supported yet")
        }</span>

        <span class="cov0" title="0">if err := s.orderRepo.Update(ctx, order); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update order: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UpdateOrderResponse{
                Order:   s.toOrderDTO(order),
                Message: "Order updated successfully",
                Success: true,
        }, nil</span>
}

func (s *orderService) DeleteOrder(ctx context.Context, orderID string) (*DeleteOrderResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid order ID format")
        }</span>

        <span class="cov0" title="0">order, err := s.orderRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order: %w", err)
        }</span>
        <span class="cov0" title="0">if order == nil </span><span class="cov0" title="0">{
                return nil, errors.New("order not found")
        }</span>

        <span class="cov0" title="0">if order.Status != domain.OrderStatusPending &amp;&amp; order.Status != domain.OrderStatusCancelled </span><span class="cov0" title="0">{
                return nil, errors.New("can only delete pending or cancelled orders")
        }</span>

        // Get order items to reverse inventory
        <span class="cov0" title="0">items, err := s.orderItemRepo.GetByOrderID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order items: %w", err)
        }</span>

        // Reverse inventory changes if order was pending
        <span class="cov0" title="0">if order.Status == domain.OrderStatusPending </span><span class="cov0" title="0">{
                for _, item := range items </span><span class="cov0" title="0">{
                        if item.Type == domain.OrderItemTypeSimple || item.Type == domain.OrderItemTypeComponent </span><span class="cov0" title="0">{
                                inventoryEntry := &amp;domain.InventoryLedger{
                                        ProductID: item.ProductID,
                                        Delta:     item.Quantity, // Positive to add back
                                        Reason:    domain.InventoryReasonRefund,
                                }
                                if err := s.inventoryLedgerRepo.Create(ctx, inventoryEntry); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to reverse inventory: %w", err)
                                }</span>
                        }
                }
        }

        // Delete order items
        <span class="cov0" title="0">if err := s.orderItemRepo.DeleteByOrderID(ctx, objectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete order items: %w", err)
        }</span>

        // Delete order
        <span class="cov0" title="0">if err := s.orderRepo.Delete(ctx, objectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete order: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DeleteOrderResponse{
                Message: "Order deleted successfully",
                Success: true,
        }, nil</span>
}

func (s *orderService) ListOrders(ctx context.Context, req ListOrdersRequest) (*ListOrdersResponse, error) <span class="cov0" title="0">{
        limit := req.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">offset := req.Offset
        if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">var orders []*domain.Order
        var err error

        if req.Status != nil </span><span class="cov0" title="0">{
                orders, err = s.orderRepo.GetByStatus(ctx, *req.Status, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                orders, err = s.orderRepo.List(ctx, limit, offset)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list orders: %w", err)
        }</span>

        <span class="cov0" title="0">orderDTOs := make([]OrderDTO, len(orders))
        for i, order := range orders </span><span class="cov0" title="0">{
                orderDTOs[i] = s.toOrderDTO(order)
        }</span>

        <span class="cov0" title="0">return &amp;ListOrdersResponse{
                Orders: orderDTOs,
                Total:  len(orderDTOs),
        }, nil</span>
}

func (s *orderService) UpdateOrderStatus(ctx context.Context, orderID string, status domain.OrderStatus) (*UpdateOrderStatusResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid order ID format")
        }</span>

        <span class="cov0" title="0">order, err := s.orderRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order: %w", err)
        }</span>
        <span class="cov0" title="0">if order == nil </span><span class="cov0" title="0">{
                return nil, errors.New("order not found")
        }</span>

        <span class="cov0" title="0">if err := s.orderRepo.UpdateStatus(ctx, objectID, status); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update order status: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UpdateOrderStatusResponse{
                Message: fmt.Sprintf("Order status updated to %s", status),
                Success: true,
        }, nil</span>
}

func (s *orderService) GetOrdersByCustomer(ctx context.Context, customerID string, limit, offset int) (*ListOrdersResponse, error) <span class="cov0" title="0">{
        id, err := primitive.ObjectIDFromHex(customerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid customer ID format")
        }</span>

        <span class="cov0" title="0">if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">orders, err := s.orderRepo.GetByCustomerID(ctx, id, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get orders by customer: %w", err)
        }</span>

        <span class="cov0" title="0">orderDTOs := make([]OrderDTO, len(orders))
        for i, order := range orders </span><span class="cov0" title="0">{
                orderDTOs[i] = s.toOrderDTO(order)
        }</span>

        <span class="cov0" title="0">return &amp;ListOrdersResponse{
                Orders: orderDTOs,
                Total:  len(orderDTOs),
        }, nil</span>
}

func (s *orderService) GetOrdersByEmail(ctx context.Context, email string, limit, offset int) (*ListOrdersResponse, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">orders, err := s.orderRepo.GetByContactEmail(ctx, email, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get orders by email: %w", err)
        }</span>

        <span class="cov0" title="0">orderDTOs := make([]OrderDTO, len(orders))
        for i, order := range orders </span><span class="cov0" title="0">{
                orderDTOs[i] = s.toOrderDTO(order)
        }</span>

        <span class="cov0" title="0">return &amp;ListOrdersResponse{
                Orders: orderDTOs,
                Total:  len(orderDTOs),
        }, nil</span>
}

func (s *orderService) toOrderDTO(order *domain.Order) OrderDTO <span class="cov0" title="0">{
        dto := OrderDTO{
                ID:        order.ID.Hex(),
                Total:     order.Total,
                Status:    string(order.Status),
                CreatedAt: order.CreatedAt.Format(time.RFC3339),
                UpdatedAt: order.UpdatedAt.Format(time.RFC3339),
        }

        if order.CustomerID != nil </span><span class="cov0" title="0">{
                customerIDStr := order.CustomerID.Hex()
                dto.CustomerID = &amp;customerIDStr
        }</span>

        <span class="cov0" title="0">if order.ContactEmail != nil </span><span class="cov0" title="0">{
                dto.ContactEmail = order.ContactEmail
        }</span>

        <span class="cov0" title="0">return dto</span>
}

func (s *orderService) toOrderItemDTO(item *domain.OrderItem) OrderItemDTO <span class="cov0" title="0">{
        dto := OrderItemDTO{
                ID:           item.ID.Hex(),
                OrderID:      item.OrderID.Hex(),
                ProductID:    item.ProductID.Hex(),
                Type:         string(item.Type),
                Title:        item.Title,
                Quantity:     item.Quantity,
                PricePerUnit: item.PricePerUnit,
                IsRedeemed:   item.IsRedeemed,
        }

        if item.ParentItemID != nil </span><span class="cov0" title="0">{
                parentID := item.ParentItemID.Hex()
                dto.ParentItemID = &amp;parentID
        }</span>

        <span class="cov0" title="0">if item.RedeemedAt != nil </span><span class="cov0" title="0">{
                redeemedAt := item.RedeemedAt.Format(time.RFC3339)
                dto.RedeemedAt = &amp;redeemedAt
        }</span>

        <span class="cov0" title="0">if item.RedeemedStationID != nil </span><span class="cov0" title="0">{
                stationID := item.RedeemedStationID.Hex()
                dto.RedeemedStationID = &amp;stationID
        }</span>

        <span class="cov0" title="0">if item.RedeemedDeviceID != nil </span><span class="cov0" title="0">{
                deviceID := item.RedeemedDeviceID.Hex()
                dto.RedeemedDeviceID = &amp;deviceID
        }</span>

        <span class="cov0" title="0">return dto</span>
}

func (s *orderService) GetOrderForRedemption(ctx context.Context, orderID, stationID string) (*OrderRedemptionResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid order ID format")
        }</span>

        <span class="cov0" title="0">stationObjectID, err := primitive.ObjectIDFromHex(stationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid station ID format")
        }</span>

        // Verify station exists
        <span class="cov0" title="0">station, err := s.stationRepo.GetByID(ctx, stationObjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get station: %w", err)
        }</span>
        <span class="cov0" title="0">if station == nil </span><span class="cov0" title="0">{
                return nil, errors.New("station not found")
        }</span>

        // Get the order
        <span class="cov0" title="0">order, err := s.orderRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order: %w", err)
        }</span>
        <span class="cov0" title="0">if order == nil </span><span class="cov0" title="0">{
                return nil, errors.New("order not found")
        }</span>

        // Only allow redemption for paid orders
        <span class="cov0" title="0">if order.Status != domain.OrderStatusPaid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("order must be paid to redeem items. Current status: %s", order.Status)
        }</span>

        // Get all order items
        <span class="cov0" title="0">allOrderItems, err := s.orderItemRepo.GetByOrderID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order items: %w", err)
        }</span>

        // Get products available at this station
        <span class="cov0" title="0">stationProducts, err := s.stationProductRepo.GetByStationID(ctx, stationObjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get station products: %w", err)
        }</span>

        // Create a map of products available at this station
        <span class="cov0" title="0">stationProductMap := make(map[primitive.ObjectID]bool)
        for _, sp := range stationProducts </span><span class="cov0" title="0">{
                stationProductMap[sp.ProductID] = true
        }</span>

        <span class="cov0" title="0">var redeemableItems []RedeemableOrderItemDTO
        var alreadyRedeemed []OrderItemDTO

        // Process order items to find what can be redeemed at this station
        for _, item := range allOrderItems </span><span class="cov0" title="0">{
                // Skip component items for now, we'll handle them through their parent bundles
                if item.Type == domain.OrderItemTypeComponent </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if item.IsRedeemed </span><span class="cov0" title="0">{
                        alreadyRedeemed = append(alreadyRedeemed, s.toOrderItemDTO(item))
                        continue</span>
                }

                // Check if this product is available at this station
                <span class="cov0" title="0">if item.Type == domain.OrderItemTypeSimple </span><span class="cov0" title="0">{
                        if stationProductMap[item.ProductID] </span><span class="cov0" title="0">{
                                product, _ := s.productRepo.GetByID(ctx, item.ProductID)
                                productName := item.Title
                                if product != nil </span><span class="cov0" title="0">{
                                        productName = product.Name
                                }</span>

                                <span class="cov0" title="0">redeemableItem := RedeemableOrderItemDTO{
                                        ID:           item.ID.Hex(),
                                        ProductID:    item.ProductID.Hex(),
                                        ProductName:  productName,
                                        Type:         string(item.Type),
                                        Quantity:     item.Quantity,
                                        PricePerUnit: item.PricePerUnit,
                                        IsBundle:     false,
                                }
                                redeemableItems = append(redeemableItems, redeemableItem)</span>
                        }
                } else<span class="cov0" title="0"> if item.Type == domain.OrderItemTypeBundle </span><span class="cov0" title="0">{
                        // For bundles, check if any components are available at this station
                        componentItems, err := s.orderItemRepo.GetByParentItemID(ctx, item.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip this bundle if we can't get components
                        }

                        <span class="cov0" title="0">var redeemableComponents []OrderItemDTO
                        hasRedeemableComponents := false

                        for _, component := range componentItems </span><span class="cov0" title="0">{
                                if stationProductMap[component.ProductID] &amp;&amp; !component.IsRedeemed </span><span class="cov0" title="0">{
                                        redeemableComponents = append(redeemableComponents, s.toOrderItemDTO(component))
                                        hasRedeemableComponents = true
                                }</span>
                        }

                        <span class="cov0" title="0">if hasRedeemableComponents </span><span class="cov0" title="0">{
                                product, _ := s.productRepo.GetByID(ctx, item.ProductID)
                                productName := item.Title
                                if product != nil </span><span class="cov0" title="0">{
                                        productName = product.Name
                                }</span>

                                <span class="cov0" title="0">redeemableItem := RedeemableOrderItemDTO{
                                        ID:             item.ID.Hex(),
                                        ProductID:      item.ProductID.Hex(),
                                        ProductName:    productName,
                                        Type:           string(item.Type),
                                        Quantity:       item.Quantity,
                                        PricePerUnit:   item.PricePerUnit,
                                        IsBundle:       true,
                                        ComponentItems: redeemableComponents,
                                }
                                redeemableItems = append(redeemableItems, redeemableItem)</span>
                        }
                }
        }

        <span class="cov0" title="0">message := "Order items available for redemption at this station"
        if len(redeemableItems) == 0 </span><span class="cov0" title="0">{
                if len(alreadyRedeemed) &gt; 0 </span><span class="cov0" title="0">{
                        message = "All items for this station have already been redeemed"
                }</span> else<span class="cov0" title="0"> {
                        message = "No items available for redemption at this station"
                }</span>
        }

        <span class="cov0" title="0">return &amp;OrderRedemptionResponse{
                Order:           s.toOrderDTO(order),
                RedeemableItems: redeemableItems,
                AlreadyRedeemed: alreadyRedeemed,
                Message:         message,
        }, nil</span>
}

func (s *orderService) RedeemOrderItems(ctx context.Context, req RedeemOrderItemsRequest) (*RedeemOrderItemsResponse, error) <span class="cov0" title="0">{
        orderObjectID, err := primitive.ObjectIDFromHex(req.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid order ID format")
        }</span>

        <span class="cov0" title="0">stationObjectID, err := primitive.ObjectIDFromHex(req.StationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid station ID format")
        }</span>

        <span class="cov0" title="0">deviceObjectID, err := primitive.ObjectIDFromHex(req.DeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid device ID format")
        }</span>

        // Verify device exists and belongs to the station
        <span class="cov0" title="0">device, err := s.deviceRepo.GetByID(ctx, deviceObjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get device: %w", err)
        }</span>
        <span class="cov0" title="0">if device == nil </span><span class="cov0" title="0">{
                return nil, errors.New("device not found")
        }</span>
        <span class="cov0" title="0">if device.StationID != stationObjectID </span><span class="cov0" title="0">{
                return nil, errors.New("device does not belong to the specified station")
        }</span>
        <span class="cov0" title="0">if !device.IsActive </span><span class="cov0" title="0">{
                return nil, errors.New("device is not active")
        }</span>

        // Get the order
        <span class="cov0" title="0">order, err := s.orderRepo.GetByID(ctx, orderObjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order: %w", err)
        }</span>
        <span class="cov0" title="0">if order == nil </span><span class="cov0" title="0">{
                return nil, errors.New("order not found")
        }</span>

        // Only allow redemption for paid orders
        <span class="cov0" title="0">if order.Status != domain.OrderStatusPaid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("order must be paid to redeem items. Current status: %s", order.Status)
        }</span>

        // Get products available at this station
        <span class="cov0" title="0">stationProducts, err := s.stationProductRepo.GetByStationID(ctx, stationObjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get station products: %w", err)
        }</span>

        // Create a map of products available at this station
        <span class="cov0" title="0">stationProductMap := make(map[primitive.ObjectID]bool)
        for _, sp := range stationProducts </span><span class="cov0" title="0">{
                stationProductMap[sp.ProductID] = true
        }</span>

        // Get all order items
        <span class="cov0" title="0">allOrderItems, err := s.orderItemRepo.GetByOrderID(ctx, orderObjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order items: %w", err)
        }</span>

        <span class="cov0" title="0">var redeemedItems []OrderItemDTO
        itemsToRedeem := make([]primitive.ObjectID, 0)

        // Find items that can be redeemed at this station
        for _, item := range allOrderItems </span><span class="cov0" title="0">{
                // Skip already redeemed items
                if item.IsRedeemed </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Handle simple products
                <span class="cov0" title="0">if item.Type == domain.OrderItemTypeSimple </span><span class="cov0" title="0">{
                        if stationProductMap[item.ProductID] </span><span class="cov0" title="0">{
                                itemsToRedeem = append(itemsToRedeem, item.ID)
                                redeemedItems = append(redeemedItems, s.toOrderItemDTO(item))
                        }</span>
                }
                // Handle bundle components
                <span class="cov0" title="0">if item.Type == domain.OrderItemTypeComponent </span><span class="cov0" title="0">{
                        if stationProductMap[item.ProductID] </span><span class="cov0" title="0">{
                                itemsToRedeem = append(itemsToRedeem, item.ID)
                                redeemedItems = append(redeemedItems, s.toOrderItemDTO(item))
                        }</span>
                }
        }

        // Check if any items were found for redemption
        <span class="cov0" title="0">if len(itemsToRedeem) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no items available for redemption at this station or all items already redeemed")
        }</span>

        // Mark items as redeemed
        <span class="cov0" title="0">for _, itemID := range itemsToRedeem </span><span class="cov0" title="0">{
                if err := s.orderItemRepo.MarkAsRedeemed(ctx, itemID, stationObjectID, deviceObjectID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to mark item as redeemed: %w", err)
                }</span>
        }

        // Check if all order items are now redeemed
        <span class="cov0" title="0">remainingItems, err := s.orderItemRepo.GetUnredeemedByOrderID(ctx, orderObjectID)
        if err == nil &amp;&amp; len(remainingItems) == 0 </span>{<span class="cov0" title="0">
                // All items redeemed, we could potentially update order status here
                // For now, we'll leave the order as "paid" since that indicates it's complete
        }</span>

        <span class="cov0" title="0">return &amp;RedeemOrderItemsResponse{
                RedeemedItems: redeemedItems,
                Message:       fmt.Sprintf("Successfully redeemed %d items at this station", len(redeemedItems)),
                Success:       true,
        }, nil</span>
}</pre>
		
		<pre class="file" id="file45" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"

        "backend/internal/domain"
        "backend/internal/repository"

        "go.mongodb.org/mongo-driver/bson/primitive"
)

type ProductService interface {
        CreateProduct(ctx context.Context, req CreateProductRequest) (*CreateProductResponse, error)
        GetProduct(ctx context.Context, productID string) (*GetProductResponse, error)
        UpdateProduct(ctx context.Context, productID string, req UpdateProductRequest) (*UpdateProductResponse, error)
        DeleteProduct(ctx context.Context, productID string) (*DeleteProductResponse, error)
        ListProducts(ctx context.Context, categoryID *string, activeOnly bool, limit, offset int) (*ListProductsResponse, error)
        SetProductActive(ctx context.Context, productID string, isActive bool) (*SetProductActiveResponse, error)
        UpdateProductStock(ctx context.Context, productID string, req UpdateProductStockRequest) (*UpdateProductStockResponse, error)
        CreateProductBundle(ctx context.Context, req CreateProductBundleRequest) (*CreateProductBundleResponse, error)
        UpdateProductBundle(ctx context.Context, bundleID string, req UpdateProductBundleRequest) (*UpdateProductBundleResponse, error)
        AssignProductToStations(ctx context.Context, productID string, stationIDs []primitive.ObjectID) (*AssignProductToStationsResponse, error)
}

type CreateProductRequest struct {
        CategoryID string             `json:"category_id" validate:"required"`
        Type       domain.ProductType `json:"type" validate:"required,oneof=simple bundle"`
        Name       string             `json:"name" validate:"required"`
        Image      *string            `json:"image,omitempty"`
        Price      float64            `json:"price" validate:"required,gte=0"`
}

type CreateProductResponse struct {
        Product ProductDTO `json:"product"`
        Message string     `json:"message"`
        Success bool       `json:"success"`
}

type GetProductResponse struct {
        Product ProductDTO `json:"product"`
}

type UpdateProductRequest struct {
        CategoryID *string             `json:"category_id,omitempty"`
        Type       *domain.ProductType `json:"type,omitempty" validate:"omitempty,oneof=simple bundle"`
        Name       *string             `json:"name,omitempty"`
        Image      *string             `json:"image,omitempty"`
        Price      *float64            `json:"price,omitempty" validate:"omitempty,gte=0"`
}

type UpdateProductResponse struct {
        Product ProductDTO `json:"product"`
        Message string     `json:"message"`
        Success bool       `json:"success"`
}

type DeleteProductResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type ListProductsResponse struct {
        Products []ProductDTO `json:"products"`
        Total    int          `json:"total"`
}

type SetProductActiveResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type UpdateProductStockRequest struct {
        Action string `json:"action" validate:"required,oneof=add subtract set"`
        Amount int    `json:"amount" validate:"required,gt=0"`
}

type UpdateProductStockResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type CreateProductBundleRequest struct {
        CategoryID string                      `json:"category_id" validate:"required"`
        Name       string                      `json:"name" validate:"required"`
        Image      *string                     `json:"image,omitempty"`
        Price      float64                     `json:"price" validate:"required,gte=0"`
        Components []ProductBundleComponentDTO `json:"components" validate:"required,dive"`
}

type CreateProductBundleResponse struct {
        Bundle     ProductDTO                  `json:"bundle"`
        Components []ProductBundleComponentDTO `json:"components"`
        Message    string                      `json:"message"`
        Success    bool                        `json:"success"`
}

type UpdateProductBundleRequest struct {
        CategoryID *string                     `json:"category_id,omitempty"`
        Name       *string                     `json:"name,omitempty"`
        Image      *string                     `json:"image,omitempty"`
        Price      *float64                    `json:"price,omitempty" validate:"omitempty,gte=0"`
        Components []ProductBundleComponentDTO `json:"components,omitempty" validate:"omitempty,dive"`
}

type UpdateProductBundleResponse struct {
        Bundle     ProductDTO                  `json:"bundle"`
        Components []ProductBundleComponentDTO `json:"components"`
        Message    string                      `json:"message"`
        Success    bool                        `json:"success"`
}

type ProductBundleComponentDTO struct {
        ComponentProductID string `json:"component_product_id" validate:"required"`
        Quantity           int    `json:"quantity" validate:"required,gt=0"`
}

type AssignProductToStationsResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type ProductDTO struct {
        ID         string  `json:"id"`
        CategoryID string  `json:"category_id"`
        Type       string  `json:"type"`
        Name       string  `json:"name"`
        Image      *string `json:"image,omitempty"`
        Price      float64 `json:"price"`
        IsActive   bool    `json:"is_active"`
        CreatedAt  string  `json:"created_at"`
        UpdatedAt  string  `json:"updated_at"`
}

type productService struct {
        productRepo         repository.ProductRepository
        categoryRepo        repository.CategoryRepository
        bundleComponentRepo repository.ProductBundleComponentRepository
        stationProductRepo  repository.StationProductRepository
}

func NewProductService(
        productRepo repository.ProductRepository,
        categoryRepo repository.CategoryRepository,
        bundleComponentRepo repository.ProductBundleComponentRepository,
        stationProductRepo repository.StationProductRepository,
) ProductService <span class="cov0" title="0">{
        return &amp;productService{
                productRepo:         productRepo,
                categoryRepo:        categoryRepo,
                bundleComponentRepo: bundleComponentRepo,
                stationProductRepo:  stationProductRepo,
        }
}</span>

func (s *productService) CreateProduct(ctx context.Context, req CreateProductRequest) (*CreateProductResponse, error) <span class="cov0" title="0">{
        categoryID, err := primitive.ObjectIDFromHex(req.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid category ID format")
        }</span>

        <span class="cov0" title="0">category, err := s.categoryRepo.GetByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to validate category: %w", err)
        }</span>
        <span class="cov0" title="0">if category == nil </span><span class="cov0" title="0">{
                return nil, errors.New("category not found")
        }</span>

        <span class="cov0" title="0">product := &amp;domain.Product{
                CategoryID: categoryID,
                Type:       req.Type,
                Name:       req.Name,
                Image:      req.Image,
                Price:      req.Price,
        }

        if err := s.productRepo.Create(ctx, product); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create product: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;CreateProductResponse{
                Product: s.toProductDTO(product),
                Message: "Product created successfully",
                Success: true,
        }, nil</span>
}

func (s *productService) GetProduct(ctx context.Context, productID string) (*GetProductResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid product ID format")
        }</span>

        <span class="cov0" title="0">product, err := s.productRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %w", err)
        }</span>
        <span class="cov0" title="0">if product == nil </span><span class="cov0" title="0">{
                return nil, errors.New("product not found")
        }</span>

        <span class="cov0" title="0">return &amp;GetProductResponse{
                Product: s.toProductDTO(product),
        }, nil</span>
}

func (s *productService) UpdateProduct(ctx context.Context, productID string, req UpdateProductRequest) (*UpdateProductResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid product ID format")
        }</span>

        <span class="cov0" title="0">product, err := s.productRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %w", err)
        }</span>
        <span class="cov0" title="0">if product == nil </span><span class="cov0" title="0">{
                return nil, errors.New("product not found")
        }</span>

        <span class="cov0" title="0">if req.CategoryID != nil </span><span class="cov0" title="0">{
                categoryID, err := primitive.ObjectIDFromHex(*req.CategoryID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid category ID format")
                }</span>
                <span class="cov0" title="0">category, err := s.categoryRepo.GetByID(ctx, categoryID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to validate category: %w", err)
                }</span>
                <span class="cov0" title="0">if category == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("category not found")
                }</span>
                <span class="cov0" title="0">product.CategoryID = categoryID</span>
        }

        <span class="cov0" title="0">if req.Type != nil </span><span class="cov0" title="0">{
                product.Type = *req.Type
        }</span>
        <span class="cov0" title="0">if req.Name != nil </span><span class="cov0" title="0">{
                product.Name = *req.Name
        }</span>
        <span class="cov0" title="0">if req.Image != nil </span><span class="cov0" title="0">{
                product.Image = req.Image
        }</span>
        <span class="cov0" title="0">if req.Price != nil </span><span class="cov0" title="0">{
                product.Price = *req.Price
        }</span>

        <span class="cov0" title="0">if err := s.productRepo.Update(ctx, product); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update product: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UpdateProductResponse{
                Product: s.toProductDTO(product),
                Message: "Product updated successfully",
                Success: true,
        }, nil</span>
}

func (s *productService) DeleteProduct(ctx context.Context, productID string) (*DeleteProductResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid product ID format")
        }</span>

        <span class="cov0" title="0">product, err := s.productRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %w", err)
        }</span>
        <span class="cov0" title="0">if product == nil </span><span class="cov0" title="0">{
                return nil, errors.New("product not found")
        }</span>

        <span class="cov0" title="0">if err := s.productRepo.Delete(ctx, objectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete product: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DeleteProductResponse{
                Message: "Product deleted successfully",
                Success: true,
        }, nil</span>
}

func (s *productService) ListProducts(ctx context.Context, categoryID *string, activeOnly bool, limit, offset int) (*ListProductsResponse, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 50
        }</span>
        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">var products []*domain.Product
        var err error

        if categoryID != nil </span><span class="cov0" title="0">{
                categoryObjID, err := primitive.ObjectIDFromHex(*categoryID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid category ID format")
                }</span>
                <span class="cov0" title="0">products, err = s.productRepo.GetByCategoryID(ctx, categoryObjID, activeOnly, limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to list products: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // List all products regardless of type
                var simpleProducts []*domain.Product
                simpleProducts, err = s.productRepo.GetByType(ctx, domain.ProductTypeSimple, limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get simple products: %w", err)
                }</span>
                <span class="cov0" title="0">var bundleProducts []*domain.Product
                bundleProducts, err = s.productRepo.GetByType(ctx, domain.ProductTypeBundle, limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get bundle products: %w", err)
                }</span>
                <span class="cov0" title="0">products = append(simpleProducts, bundleProducts...)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list products: %w", err)
        }</span>

        <span class="cov0" title="0">productDTOs := make([]ProductDTO, len(products))
        for i, product := range products </span><span class="cov0" title="0">{
                productDTOs[i] = s.toProductDTO(product)
        }</span>

        <span class="cov0" title="0">return &amp;ListProductsResponse{
                Products: productDTOs,
                Total:    len(productDTOs),
        }, nil</span>
}

func (s *productService) SetProductActive(ctx context.Context, productID string, isActive bool) (*SetProductActiveResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid product ID format")
        }</span>

        <span class="cov0" title="0">product, err := s.productRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %w", err)
        }</span>
        <span class="cov0" title="0">if product == nil </span><span class="cov0" title="0">{
                return nil, errors.New("product not found")
        }</span>

        <span class="cov0" title="0">if err := s.productRepo.SetActive(ctx, objectID, isActive); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update product status: %w", err)
        }</span>

        <span class="cov0" title="0">var action string
        if isActive </span><span class="cov0" title="0">{
                action = "activated"
        }</span> else<span class="cov0" title="0"> {
                action = "deactivated"
        }</span>

        <span class="cov0" title="0">return &amp;SetProductActiveResponse{
                Message: fmt.Sprintf("Product %s successfully", action),
                Success: true,
        }, nil</span>
}

func (s *productService) UpdateProductStock(ctx context.Context, productID string, req UpdateProductStockRequest) (*UpdateProductStockResponse, error) <span class="cov0" title="0">{
        return &amp;UpdateProductStockResponse{
                Message: "Stock update functionality not yet implemented",
                Success: false,
        }, nil
}</span>

func (s *productService) CreateProductBundle(ctx context.Context, req CreateProductBundleRequest) (*CreateProductBundleResponse, error) <span class="cov0" title="0">{
        categoryID, err := primitive.ObjectIDFromHex(req.CategoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid category ID format")
        }</span>

        <span class="cov0" title="0">category, err := s.categoryRepo.GetByID(ctx, categoryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to validate category: %w", err)
        }</span>
        <span class="cov0" title="0">if category == nil </span><span class="cov0" title="0">{
                return nil, errors.New("category not found")
        }</span>

        <span class="cov0" title="0">bundle := &amp;domain.Product{
                CategoryID: categoryID,
                Type:       domain.ProductTypeBundle,
                Name:       req.Name,
                Image:      req.Image,
                Price:      req.Price,
        }

        if err := s.productRepo.Create(ctx, bundle); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create bundle: %w", err)
        }</span>

        <span class="cov0" title="0">for _, comp := range req.Components </span><span class="cov0" title="0">{
                componentID, err := primitive.ObjectIDFromHex(comp.ComponentProductID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid component product ID format: %s", comp.ComponentProductID)
                }</span>

                <span class="cov0" title="0">component, err := s.productRepo.GetByID(ctx, componentID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to validate component product: %w", err)
                }</span>
                <span class="cov0" title="0">if component == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("component product not found: %s", comp.ComponentProductID)
                }</span>

                <span class="cov0" title="0">bundleComponent := &amp;domain.ProductBundleComponent{
                        BundleID:           bundle.ID,
                        ComponentProductID: componentID,
                        Quantity:           comp.Quantity,
                }

                if err := s.bundleComponentRepo.Create(ctx, bundleComponent); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create bundle component: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;CreateProductBundleResponse{
                Bundle:     s.toProductDTO(bundle),
                Components: req.Components,
                Message:    "Product bundle created successfully",
                Success:    true,
        }, nil</span>
}

func (s *productService) UpdateProductBundle(ctx context.Context, bundleID string, req UpdateProductBundleRequest) (*UpdateProductBundleResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(bundleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid bundle ID format")
        }</span>

        <span class="cov0" title="0">bundle, err := s.productRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get bundle: %w", err)
        }</span>
        <span class="cov0" title="0">if bundle == nil </span><span class="cov0" title="0">{
                return nil, errors.New("bundle not found")
        }</span>
        <span class="cov0" title="0">if bundle.Type != domain.ProductTypeBundle </span><span class="cov0" title="0">{
                return nil, errors.New("product is not a bundle")
        }</span>

        <span class="cov0" title="0">if req.CategoryID != nil </span><span class="cov0" title="0">{
                categoryID, err := primitive.ObjectIDFromHex(*req.CategoryID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid category ID format")
                }</span>
                <span class="cov0" title="0">category, err := s.categoryRepo.GetByID(ctx, categoryID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to validate category: %w", err)
                }</span>
                <span class="cov0" title="0">if category == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("category not found")
                }</span>
                <span class="cov0" title="0">bundle.CategoryID = categoryID</span>
        }

        <span class="cov0" title="0">if req.Name != nil </span><span class="cov0" title="0">{
                bundle.Name = *req.Name
        }</span>
        <span class="cov0" title="0">if req.Image != nil </span><span class="cov0" title="0">{
                bundle.Image = req.Image
        }</span>
        <span class="cov0" title="0">if req.Price != nil </span><span class="cov0" title="0">{
                bundle.Price = *req.Price
        }</span>

        <span class="cov0" title="0">if err := s.productRepo.Update(ctx, bundle); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update bundle: %w", err)
        }</span>

        <span class="cov0" title="0">if req.Components != nil </span><span class="cov0" title="0">{
                if err := s.bundleComponentRepo.DeleteByBundleID(ctx, objectID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to remove existing components: %w", err)
                }</span>

                <span class="cov0" title="0">for _, comp := range req.Components </span><span class="cov0" title="0">{
                        componentID, err := primitive.ObjectIDFromHex(comp.ComponentProductID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid component product ID format: %s", comp.ComponentProductID)
                        }</span>

                        <span class="cov0" title="0">component, err := s.productRepo.GetByID(ctx, componentID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to validate component product: %w", err)
                        }</span>
                        <span class="cov0" title="0">if component == nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("component product not found: %s", comp.ComponentProductID)
                        }</span>

                        <span class="cov0" title="0">bundleComponent := &amp;domain.ProductBundleComponent{
                                BundleID:           bundle.ID,
                                ComponentProductID: componentID,
                                Quantity:           comp.Quantity,
                        }

                        if err := s.bundleComponentRepo.Create(ctx, bundleComponent); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to create bundle component: %w", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;UpdateProductBundleResponse{
                Bundle:     s.toProductDTO(bundle),
                Components: req.Components,
                Message:    "Product bundle updated successfully",
                Success:    true,
        }, nil</span>
}

func (s *productService) AssignProductToStations(ctx context.Context, productID string, stationIDs []primitive.ObjectID) (*AssignProductToStationsResponse, error) <span class="cov0" title="0">{
        objectID, err := primitive.ObjectIDFromHex(productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid product ID format")
        }</span>

        <span class="cov0" title="0">product, err := s.productRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get product: %w", err)
        }</span>
        <span class="cov0" title="0">if product == nil </span><span class="cov0" title="0">{
                return nil, errors.New("product not found")
        }</span>

        <span class="cov0" title="0">for _, stationID := range stationIDs </span><span class="cov0" title="0">{
                stationProduct := &amp;domain.StationProduct{
                        StationID: stationID,
                        ProductID: objectID,
                }

                if err := s.stationProductRepo.Create(ctx, stationProduct); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to assign product to station %s: %w", stationID.Hex(), err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;AssignProductToStationsResponse{
                Message: fmt.Sprintf("Product assigned to %d stations successfully", len(stationIDs)),
                Success: true,
        }, nil</span>
}

func (s *productService) toProductDTO(product *domain.Product) ProductDTO <span class="cov0" title="0">{
        return ProductDTO{
                ID:         product.ID.Hex(),
                CategoryID: product.CategoryID.Hex(),
                Type:       string(product.Type),
                Name:       product.Name,
                Image:      product.Image,
                Price:      product.Price,
                IsActive:   product.IsActive,
                CreatedAt:  product.CreatedAt.Format("2006-01-02T15:04:05Z07:00"),
                UpdatedAt:  product.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"),
        }
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package service

import (
        "context"
        "errors"

        "backend/internal/domain"
        "backend/internal/repository"

        "go.mongodb.org/mongo-driver/bson/primitive"
        "go.mongodb.org/mongo-driver/mongo"
)

type StationService interface {
        CreateStation(ctx context.Context, req *domain.StationRequest) (*StationResponse, error)
        ListStations(ctx context.Context, limit, offset int) (*ListStationsResponse, error)
        ListStationsByStatus(ctx context.Context, status domain.StationStatus, limit, offset int) (*ListStationsResponse, error)
        GetStation(ctx context.Context, stationID primitive.ObjectID) (*StationResponse, error)
        ApproveStation(ctx context.Context, stationID, adminID primitive.ObjectID) (*StatusResponse, error)
        RejectStation(ctx context.Context, stationID, adminID primitive.ObjectID, reason string) (*StatusResponse, error)
        AssignProductsToStation(ctx context.Context, stationID primitive.ObjectID, productIDs []primitive.ObjectID) (*AssignProductsResponse, error)
        GetStationProducts(ctx context.Context, stationID primitive.ObjectID) (*StationProductsResponse, error)
        RemoveProductFromStation(ctx context.Context, stationID, productID primitive.ObjectID) (*AssignProductsResponse, error)
}

type StationResponse struct {
        ID              string  `json:"id"`
        Name            string  `json:"name"`
        Status          string  `json:"status"`
        ApprovedBy      *string `json:"approved_by,omitempty"`
        ApprovedAt      *string `json:"approved_at,omitempty"`
        RejectedBy      *string `json:"rejected_by,omitempty"`
        RejectedAt      *string `json:"rejected_at,omitempty"`
        RejectionReason *string `json:"rejection_reason,omitempty"`
        CreatedAt       string  `json:"created_at"`
        UpdatedAt       string  `json:"updated_at"`
}

type ListStationsResponse struct {
        Stations []StationResponse `json:"stations"`
        Total    int               `json:"total"`
}

type StatusResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type AssignProductsResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type Product struct {
        ID    string  `json:"id"`
        Name  string  `json:"name"`
        Price float64 `json:"price"`
}

type StationProductsResponse struct {
        StationID string    `json:"station_id"`
        Products  []Product `json:"products"`
}

type stationService struct {
        stationRepo        repository.StationRepository
        stationProductRepo repository.StationProductRepository
        productRepo        repository.ProductRepository
        userRepo           repository.UserRepository
}

func NewStationService(
        stationRepo repository.StationRepository,
        stationProductRepo repository.StationProductRepository,
        productRepo repository.ProductRepository,
        userRepo repository.UserRepository,
) StationService <span class="cov0" title="0">{
        return &amp;stationService{
                stationRepo:        stationRepo,
                stationProductRepo: stationProductRepo,
                productRepo:        productRepo,
                userRepo:           userRepo,
        }
}</span>

func (s *stationService) CreateStation(ctx context.Context, req *domain.StationRequest) (*StationResponse, error) <span class="cov0" title="0">{
        // Check if station name already exists
        existingStation, err := s.stationRepo.GetByName(ctx, req.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if existingStation != nil </span><span class="cov0" title="0">{
                return nil, errors.New("station with this name already exists")
        }</span>

        <span class="cov0" title="0">station := &amp;domain.Station{
                Name:   req.Name,
                Status: domain.StationStatusPending,
        }

        err = s.stationRepo.Create(ctx, station)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.mapStationToResponse(station), nil</span>
}

func (s *stationService) ListStations(ctx context.Context, limit, offset int) (*ListStationsResponse, error) <span class="cov0" title="0">{
        stations, err := s.stationRepo.List(ctx, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">responses := make([]StationResponse, len(stations))
        for i, station := range stations </span><span class="cov0" title="0">{
                responses[i] = *s.mapStationToResponse(station)
        }</span>

        <span class="cov0" title="0">return &amp;ListStationsResponse{
                Stations: responses,
                Total:    len(responses),
        }, nil</span>
}

func (s *stationService) ListStationsByStatus(ctx context.Context, status domain.StationStatus, limit, offset int) (*ListStationsResponse, error) <span class="cov0" title="0">{
        stations, err := s.stationRepo.ListByStatus(ctx, status, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">responses := make([]StationResponse, len(stations))
        for i, station := range stations </span><span class="cov0" title="0">{
                responses[i] = *s.mapStationToResponse(station)
        }</span>

        <span class="cov0" title="0">return &amp;ListStationsResponse{
                Stations: responses,
                Total:    len(responses),
        }, nil</span>
}


func (s *stationService) GetStation(ctx context.Context, stationID primitive.ObjectID) (*StationResponse, error) <span class="cov0" title="0">{
        station, err := s.stationRepo.GetByID(ctx, stationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if station == nil </span><span class="cov0" title="0">{
                return nil, errors.New("station not found")
        }</span>

        <span class="cov0" title="0">return s.mapStationToResponse(station), nil</span>
}

func (s *stationService) ApproveStation(ctx context.Context, stationID, adminID primitive.ObjectID) (*StatusResponse, error) <span class="cov0" title="0">{
        err := s.stationRepo.ApproveStation(ctx, stationID, adminID)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return &amp;StatusResponse{
                                Message: "Station not found or not pending approval",
                                Success: false,
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;StatusResponse{
                Message: "Station approved successfully",
                Success: true,
        }, nil</span>
}

func (s *stationService) RejectStation(ctx context.Context, stationID, adminID primitive.ObjectID, reason string) (*StatusResponse, error) <span class="cov0" title="0">{
        err := s.stationRepo.RejectStation(ctx, stationID, adminID, reason)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return &amp;StatusResponse{
                                Message: "Station not found or not pending approval",
                                Success: false,
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;StatusResponse{
                Message: "Station rejected successfully",
                Success: true,
        }, nil</span>
}

func (s *stationService) AssignProductsToStation(ctx context.Context, stationID primitive.ObjectID, productIDs []primitive.ObjectID) (*AssignProductsResponse, error) <span class="cov0" title="0">{
        // Verify station exists and is approved
        station, err := s.stationRepo.GetByID(ctx, stationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if station == nil </span><span class="cov0" title="0">{
                return &amp;AssignProductsResponse{
                        Message: "Station not found",
                        Success: false,
                }, nil
        }</span>
        <span class="cov0" title="0">if station.Status != domain.StationStatusApproved </span><span class="cov0" title="0">{
                return &amp;AssignProductsResponse{
                        Message: "Station must be approved to assign products",
                        Success: false,
                }, nil
        }</span>

        // Verify all products exist
        <span class="cov0" title="0">for _, productID := range productIDs </span><span class="cov0" title="0">{
                product, err := s.productRepo.GetByID(ctx, productID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if product == nil </span><span class="cov0" title="0">{
                        return &amp;AssignProductsResponse{
                                Message: "One or more products not found",
                                Success: false,
                        }, nil
                }</span>
        }

        // Create station-product associations
        <span class="cov0" title="0">for _, productID := range productIDs </span><span class="cov0" title="0">{
                stationProduct := &amp;domain.StationProduct{
                        StationID: stationID,
                        ProductID: productID,
                }
                err := s.stationProductRepo.Create(ctx, stationProduct)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return &amp;AssignProductsResponse{
                Message: "Products assigned to station successfully",
                Success: true,
        }, nil</span>
}

func (s *stationService) GetStationProducts(ctx context.Context, stationID primitive.ObjectID) (*StationProductsResponse, error) <span class="cov0" title="0">{
        stationProducts, err := s.stationProductRepo.GetByStationID(ctx, stationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">products := make([]Product, 0, len(stationProducts))
        for _, sp := range stationProducts </span><span class="cov0" title="0">{
                product, err := s.productRepo.GetByID(ctx, sp.ProductID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if product != nil </span><span class="cov0" title="0">{
                        products = append(products, Product{
                                ID:    product.ID.Hex(),
                                Name:  product.Name,
                                Price: product.Price,
                        })
                }</span>
        }

        <span class="cov0" title="0">return &amp;StationProductsResponse{
                StationID: stationID.Hex(),
                Products:  products,
        }, nil</span>
}

func (s *stationService) RemoveProductFromStation(ctx context.Context, stationID, productID primitive.ObjectID) (*AssignProductsResponse, error) <span class="cov0" title="0">{
        err := s.stationProductRepo.Delete(ctx, stationID, productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;AssignProductsResponse{
                Message: "Product removed from station successfully",
                Success: true,
        }, nil</span>
}

func (s *stationService) mapStationToResponse(station *domain.Station) *StationResponse <span class="cov0" title="0">{
        response := &amp;StationResponse{
                ID:        station.ID.Hex(),
                Name:      station.Name,
                Status:    string(station.Status),
                CreatedAt: station.CreatedAt.Format("2006-01-02T15:04:05Z"),
                UpdatedAt: station.UpdatedAt.Format("2006-01-02T15:04:05Z"),
        }

        if station.ApprovedBy != nil </span><span class="cov0" title="0">{
                approvedBy := station.ApprovedBy.Hex()
                response.ApprovedBy = &amp;approvedBy
        }</span>
        <span class="cov0" title="0">if station.ApprovedAt != nil </span><span class="cov0" title="0">{
                approvedAt := station.ApprovedAt.Format("2006-01-02T15:04:05Z")
                response.ApprovedAt = &amp;approvedAt
        }</span>
        <span class="cov0" title="0">if station.RejectedBy != nil </span><span class="cov0" title="0">{
                rejectedBy := station.RejectedBy.Hex()
                response.RejectedBy = &amp;rejectedBy
        }</span>
        <span class="cov0" title="0">if station.RejectedAt != nil </span><span class="cov0" title="0">{
                rejectedAt := station.RejectedAt.Format("2006-01-02T15:04:05Z")
                response.RejectedAt = &amp;rejectedAt
        }</span>
        <span class="cov0" title="0">if station.RejectionReason != nil </span><span class="cov0" title="0">{
                response.RejectionReason = station.RejectionReason
        }</span>

        <span class="cov0" title="0">return response</span>
}</pre>
		
		<pre class="file" id="file47" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"

        "backend/internal/domain"
        "backend/internal/repository"

        "go.mongodb.org/mongo-driver/bson/primitive"
)

// UserService defines the user management service interface
type UserService interface {
        UpdateProfile(ctx context.Context, userID string, req UpdateProfileRequest) (*UpdateProfileResponse, error)
        DeleteProfile(ctx context.Context, userID string) (*DeleteProfileResponse, error)
        GetProfile(ctx context.Context, userID string) (*domain.User, error)
}

// Request/Response types for Profile Update
type UpdateProfileRequest struct {
        Email string `json:"email" validate:"required,email"`
}

type UpdateProfileResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

// Request/Response types for Profile Delete
type DeleteProfileResponse struct {
        Message string `json:"message"`
        Success bool   `json:"success"`
}

type userService struct {
        userRepo repository.UserRepository
}

func NewUserService(userRepo repository.UserRepository) UserService <span class="cov0" title="0">{
        return &amp;userService{
                userRepo: userRepo,
        }
}</span>

func (s *userService) UpdateProfile(ctx context.Context, userID string, req UpdateProfileRequest) (*UpdateProfileResponse, error) <span class="cov0" title="0">{
        // Convert userID to ObjectID
        objectID, err := primitive.ObjectIDFromHex(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid user ID format")
        }</span>

        // Get current user
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>

        // Check if user is disabled
        <span class="cov0" title="0">if user.IsDisabled </span><span class="cov0" title="0">{
                return nil, errors.New("account is disabled")
        }</span>

        // Check if the new email is already in use by another user
        <span class="cov0" title="0">existingUser, err := s.userRepo.GetByEmail(ctx, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check email availability: %w", err)
        }</span>
        <span class="cov0" title="0">if existingUser != nil &amp;&amp; existingUser.ID != user.ID </span><span class="cov0" title="0">{
                return nil, errors.New("email address is already in use")
        }</span>

        // Update user email
        <span class="cov0" title="0">user.Email = req.Email

        // Save updated user
        if err := s.userRepo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update profile: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;UpdateProfileResponse{
                Message: "Profile updated successfully",
                Success: true,
        }, nil</span>
}

func (s *userService) DeleteProfile(ctx context.Context, userID string) (*DeleteProfileResponse, error) <span class="cov0" title="0">{
        // Convert userID to ObjectID
        objectID, err := primitive.ObjectIDFromHex(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid user ID format")
        }</span>

        // Get current user to verify it exists
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>

        // Ensure only customers can delete their own profiles
        <span class="cov0" title="0">if user.Role != domain.UserRoleCustomer </span><span class="cov0" title="0">{
                return nil, errors.New("only customer accounts can be self-deleted")
        }</span>

        // Delete user
        <span class="cov0" title="0">if err := s.userRepo.Delete(ctx, objectID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to delete profile: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;DeleteProfileResponse{
                Message: "Profile deleted successfully",
                Success: true,
        }, nil</span>
}

func (s *userService) GetProfile(ctx context.Context, userID string) (*domain.User, error) <span class="cov0" title="0">{
        // Convert userID to ObjectID
        objectID, err := primitive.ObjectIDFromHex(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid user ID format")
        }</span>

        // Get user
        <span class="cov0" title="0">user, err := s.userRepo.GetByID(ctx, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}</pre>
		
		<pre class="file" id="file48" style="display: none">package utils

import (
        "crypto/rand"
        "crypto/subtle"
        "encoding/base64"
        "errors"
        "fmt"
        "math/big"
        "strconv"
        "strings"

        "golang.org/x/crypto/argon2"
)

const (
        ArgonTime       = uint32(3)         // iterations
        ArgonMemory     = uint32(64 * 1024) // 64 MiB
        ArgonThreads    = uint8(1)          // parallelism
        ArgonKeyLen     = uint32(32)        // 32 bytes
        ArgonSaltLength = 16                // 16 bytes
)

type argon2Params struct {
        memory  uint32
        time    uint32
        threads uint8
}

// HashOTPArgon2 hashes an OTP code using Argon2id and returns PHC format string
func HashOTPArgon2(code string) (string, error) <span class="cov0" title="0">{
        salt := make([]byte, ArgonSaltLength)
        if _, err := rand.Read(salt); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("salt: %w", err)
        }</span>
        <span class="cov0" title="0">hash := argon2.IDKey([]byte(code), salt, ArgonTime, ArgonMemory, ArgonThreads, ArgonKeyLen)

        encSalt := base64.RawStdEncoding.EncodeToString(salt)
        encHash := base64.RawStdEncoding.EncodeToString(hash)
        return fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
                argon2.Version, ArgonMemory, ArgonTime, ArgonThreads, encSalt, encHash), nil</span>
}

// VerifyOTPArgon2 verifies an OTP code against its Argon2id hash
func VerifyOTPArgon2(code, encoded string) (bool, error) <span class="cov0" title="0">{
        p, salt, expected, err := parsePHC(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">computed := argon2.IDKey([]byte(code), salt, p.time, p.memory, p.threads, uint32(len(expected)))
        return subtle.ConstantTimeCompare(computed, expected) == 1, nil</span>
}

// GenerateOTP generates a 6-digit OTP code
func GenerateOTP() (string, error) <span class="cov0" title="0">{
        n, err := rand.Int(rand.Reader, big.NewInt(1_000_000))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("rand: %w", err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%06d", n.Int64()), nil</span>
}

// GenerateFamilyID generates a random family ID for refresh token rotation
func GenerateFamilyID() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate family ID: %w", err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%x", bytes), nil</span>
}

// parsePHC parses a PHC formatted Argon2 hash string
func parsePHC(encoded string) (p argon2Params, salt, hash []byte, err error) <span class="cov0" title="0">{
        parts := strings.Split(encoded, "$")
        if len(parts) != 6 || parts[0] != "" || parts[1] != "argon2id" </span><span class="cov0" title="0">{
                return p, nil, nil, errors.New("invalid argon2 encoded hash format")
        }</span>
        // version
        <span class="cov0" title="0">if !strings.HasPrefix(parts[2], "v=") </span><span class="cov0" title="0">{
                return p, nil, nil, errors.New("missing version")
        }</span>
        <span class="cov0" title="0">v, err := strconv.Atoi(strings.TrimPrefix(parts[2], "v="))
        if err != nil || v != argon2.Version </span><span class="cov0" title="0">{
                return p, nil, nil, fmt.Errorf("unsupported argon2 version: %v", parts[2])
        }</span>
        // params m,t,p
        <span class="cov0" title="0">paramKV := strings.Split(parts[3], ",")
        if len(paramKV) != 3 </span><span class="cov0" title="0">{
                return p, nil, nil, errors.New("invalid param segment")
        }</span>
        <span class="cov0" title="0">get := func(prefix string) (string, error) </span><span class="cov0" title="0">{
                for _, kv := range paramKV </span><span class="cov0" title="0">{
                        if value, found := strings.CutPrefix(kv, prefix); found </span><span class="cov0" title="0">{
                                return value, nil
                        }</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("missing %s", prefix)</span>
        }
        <span class="cov0" title="0">memStr, err := get("m=")
        if err != nil </span><span class="cov0" title="0">{
                return p, nil, nil, err
        }</span>
        <span class="cov0" title="0">timeStr, err := get("t=")
        if err != nil </span><span class="cov0" title="0">{
                return p, nil, nil, err
        }</span>
        <span class="cov0" title="0">thStr, err := get("p=")
        if err != nil </span><span class="cov0" title="0">{
                return p, nil, nil, err
        }</span>
        <span class="cov0" title="0">mem, err := strconv.ParseUint(memStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return p, nil, nil, fmt.Errorf("memory: %w", err)
        }</span>
        <span class="cov0" title="0">t, err := strconv.ParseUint(timeStr, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return p, nil, nil, fmt.Errorf("time: %w", err)
        }</span>
        <span class="cov0" title="0">th, err := strconv.ParseUint(thStr, 10, 8)
        if err != nil </span><span class="cov0" title="0">{
                return p, nil, nil, fmt.Errorf("threads: %w", err)
        }</span>
        <span class="cov0" title="0">p = argon2Params{memory: uint32(mem), time: uint32(t), threads: uint8(th)}

        // salt/hash
        salt, err = base64.RawStdEncoding.DecodeString(parts[4])
        if err != nil </span><span class="cov0" title="0">{
                return p, nil, nil, fmt.Errorf("salt b64: %w", err)
        }</span>
        <span class="cov0" title="0">hash, err = base64.RawStdEncoding.DecodeString(parts[5])
        if err != nil </span><span class="cov0" title="0">{
                return p, nil, nil, fmt.Errorf("hash b64: %w", err)
        }</span>
        <span class="cov0" title="0">return p, salt, hash, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

name: Build Images

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [staging, production]
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Branch to build for'
        type: choice
        options: [staging, production]
        default: staging
      force_build:
        description: 'Force build all images'
        type: boolean
        default: false

permissions:
  contents: read
  packages: write
  actions: write
  attestations: write
  id-token: write

concurrency:
  group: build-${{ github.event.workflow_run.head_branch || github.event.inputs.target_branch || github.ref_name }}
  cancel-in-progress: false

jobs:
  verify-ci:
    # Only run for (a) CI-completed runs on staging/production, or (b) manual builds
    if: |
      (github.event_name == 'workflow_run' &&
       (github.event.workflow_run.head_branch == 'staging' || github.event.workflow_run.head_branch == 'production')) ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Ensure CI succeeded for target branch
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        with:
          target_branch: ${{ github.event.inputs.target_branch || 'staging' }}
          script: |
            const eventName = context.eventName;
            const { owner, repo } = context.repo;

            if (eventName === 'workflow_run') {
              const conclusion = context.payload.workflow_run?.conclusion;
              const headBranch = context.payload.workflow_run?.head_branch;
              if (!['staging','production'].includes(headBranch)) {
                core.setFailed(`Ignoring workflow_run for non-deploy branch '${headBranch}'.`);
                return;
              }
              if (conclusion !== 'success') {
                core.setFailed(`CI workflow did not succeed (conclusion: ${conclusion})`);
              } else {
                core.notice('âœ… CI workflow succeeded (workflow_run).');
              }
              return;
            }

            const targetBranch = core.getInput('target_branch') || 'staging';

            const ciWf = await github.rest.actions.getWorkflow({ owner, repo, workflow_id: 'ci.yml' });
            const runs = await github.rest.actions.listWorkflowRuns({ owner, repo, workflow_id: ciWf.data.id, branch: targetBranch, per_page: 1 });
            const run = runs.data.workflow_runs?.[0];
            if (!run) {
              core.setFailed(`No CI run found on branch '${targetBranch}'. Push to '${targetBranch}' to run CI.`);
              return;
            }
            if (run.status !== 'completed') {
              core.setFailed(`CI run on '${targetBranch}' is not completed (status: ${run.status}).`);
              return;
            }
            if (run.conclusion !== 'success') {
              core.setFailed(`CI run on '${targetBranch}' did not succeed (conclusion: ${run.conclusion}).`);
              return;
            }
            core.notice(`âœ… CI on '${targetBranch}' succeeded (run id: ${run.id}). Proceeding with build.`);

  changes:
    needs: [verify-ci]
    if: needs.verify-ci.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      branch: ${{ steps.branch.outputs.name }}
      sha: ${{ steps.branch.outputs.sha }}
    steps:
      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.event.inputs.target_branch || github.ref_name }}
          fetch-depth: 0
          persist-credentials: false

      - name: Set branch and SHA
        id: branch
        run: |
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "name=${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
            echo "sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
          else
            BRANCH="${{ github.event.inputs.target_branch || github.ref_name }}"
            echo "name=$BRANCH" >> $GITHUB_OUTPUT
            echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          fi

      - uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36
        id: filter
        with:
          base: ${{ github.event.workflow_run.head_branch || github.event.inputs.target_branch || github.ref_name }}
          filters: |
            backend:
              - 'bfs-backend/**'
              - '.github/workflows/build-images.yml'
            frontend:
              - 'bfs-web-app/**'
              - '.github/workflows/build-images.yml'

  build:
    needs: changes
    if: |
      github.event.inputs.force_build == 'true' ||
      needs.changes.outputs.backend == 'true' ||
      needs.changes.outputs.frontend == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      matrix:
        image:
          - name: backend
            context: bfs-backend
            dockerfile: bfs-backend/Dockerfile
          - name: frontend
            context: bfs-web-app
            dockerfile: bfs-web-app/Dockerfile
    steps:
      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11
        with:
          ref: ${{ needs.changes.outputs.sha }}
          persist-credentials: false

      - uses: docker/setup-buildx-action@988b5a0280414f521da01fcc63a27aeeb4b104db

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@8e5442c4ef9f78752691e2d8f8d19755c6f78e81
        with:
          images: ghcr.io/${{ github.repository }}/${{ matrix.image.name }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-,format=short
            type=raw,value=latest,enable=${{ needs.changes.outputs.branch == 'production' }}

      - name: Build and push
        id: build
        uses: docker/build-push-action@4f58ea79222b3b9dc2c8bbdd6debcef730109a75
        with:
          context: ${{ matrix.image.context }}
          file: ${{ matrix.image.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=registry,ref=ghcr.io/${{ github.repository }}/${{ matrix.image.name }}:${{ needs.changes.outputs.branch }}-cache
            type=gha,scope=${{ matrix.image.name }}
          cache-to: |
            type=registry,ref=ghcr.io/${{ github.repository }}/${{ matrix.image.name }}:${{ needs.changes.outputs.branch }}-cache,mode=max
            type=gha,mode=max,scope=${{ matrix.image.name }}
          sbom: true
          provenance: true

      - name: Generate SBOM attestation
        uses: actions/attest-sbom@5026d3663739160db546203eeaffa6aa1c51a4d6
        with:
          subject-name: ghcr.io/${{ github.repository }}/${{ matrix.image.name }}
          subject-digest: ${{ steps.build.outputs.digest }}
          sbom-path: ${{ matrix.image.context }}/sbom.json
          push-to-registry: true
        continue-on-error: true

      - name: Save digest
        run: |
          mkdir -p /tmp/digests
          echo "${{ matrix.image.name }}=${{ steps.build.outputs.digest }}" >> /tmp/digests/${{ matrix.image.name }}.txt

      - name: Upload digest
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874
        with:
          name: digest-${{ matrix.image.name }}
          path: /tmp/digests/${{ matrix.image.name }}.txt
          retention-days: 1

  merge-digests:
    needs: [changes, build]
    if: always() && needs.build.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Download digests
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53
        with:
          pattern: digest-*
          path: /tmp/digests
          merge-multiple: true

      - name: Display digests
        run: |
          echo "Image digests:"
          cat /tmp/digests/*.txt

      - name: Upload merged digests
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874
        with:
          name: image-digests
          path: /tmp/digests
          retention-days: 7

  build-summary:
    needs: [changes, build, merge-digests]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Build summary
        run: |
          echo "## ðŸ³ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ needs.changes.outputs.branch }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ needs.changes.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.build.result }}" == "success" ]; then
            echo "âœ… Images built successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Image build failed" >> $GITHUB_STEP_SUMMARY
          fi

  trigger-deploy:
    name: Trigger Deploy
    runs-on: ubuntu-latest
    needs: [changes, build, merge-digests]
    if: |
      needs.build.result == 'success' &&
      needs.merge-digests.result == 'success' &&
      (needs.changes.outputs.branch == 'staging' || needs.changes.outputs.branch == 'production')
    steps:
      - name: Trigger deploy workflow
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
        with:
          script: |
            const { owner, repo } = context.repo;
            const environment = '${{ needs.changes.outputs.branch }}';
            const imageTag = '${{ needs.changes.outputs.branch }}';

            console.log(`Triggering deploy workflow for environment: ${environment}`);

            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: 'deploy.yml',
              ref: environment,
              inputs: {
                environment: environment,
                image_tag: imageTag
              }
            });

            console.log('âœ… Deploy workflow triggered successfully');
